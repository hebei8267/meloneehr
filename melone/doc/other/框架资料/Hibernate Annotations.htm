
<!-- saved from url=(0076)http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      
   <title>Hibernate Annotations</title><link rel="stylesheet" href="./Hibernate Annotations_files/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="zh_cn"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Hibernate Annotations</h1></div><div><h2 class="subtitle">参考文档</h2></div><div><p class="releaseinfo">3.2.0 CR1</p></div></div><div></div><hr></div><div class="toc"><p><b>目录</b></p><dl><dt><span class="preface"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#preface">前言</a></span></dt><dd><dl><dt><span class="sect1"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#preface-translate-comments-zh-cn">1. 翻译说明</a></span></dt><dt><span class="sect1"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#preface-translate-licence-zh-cn">2. 版权声明</a></span></dt></dl></dd><dt><span class="preface"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e199">前言</a></span></dt><dt><span class="chapter"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e224">1. 创建一个注解项目</a></span></dt><dd><dl><dt><span class="section"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#setup-requirements">1.1. 系统需求</a></span></dt><dt><span class="section"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#setup-configuration">1.2. 系统配置</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity">2. 实体Bean</a></span></dt><dd><dl><dt><span class="sect1"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-overview">2.1. 简介</a></span></dt><dt><span class="sect1"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#mapping">2.2. 用EJB3注解进行映射</a></span></dt><dd><dl><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e346">2.2.1. 声明实体bean</a></span></dt><dd><dl><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e384">2.2.1.1. 定义表(Table)</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e427">2.2.1.2. 乐观锁定版本控制</a></span></dt></dl></dd><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e447">2.2.2. 映射简单属性</a></span></dt><dd><dl><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e450">2.2.2.1. 声明基本的属性映射</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e559">2.2.2.2. 声明列属性</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e687">2.2.2.3. 嵌入式对象(又名组件)</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e784">2.2.2.4. 无注解之属性的默认值</a></span></dt></dl></dd><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#mapping-identifier">2.2.. 映射主键属性</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e936">2.2.4. 映射继承关系</a></span></dt><dd><dl><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e956">2.2.4.1. 每个类一张表</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e977">2.2.4.2. 每个类层次结构一张表</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e1014">2.2.4.3. 连接的子类</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e1047">2.2.4.4. 从父类继承的属性</a></span></dt></dl></dd><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-mapping-association">2.2.5. 映射实体Bean的关联关系</a></span></dt><dd><dl><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e1148">2.2.5.1. 一对一(One-to-one)</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e1291">2.2.5.2. 多对一(Many-to-one)</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-mapping-association-collections">2.2.5.3. 集合类型</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e1715">2.2.5.4. 用cascading实现传播性持久化(Transitive persistence)</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e1739">2.2.5.5. 关联关系获取</a></span></dt></dl></dd><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e1765">2.2.6. 映射复合主键与外键</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e1823">2.2.7. 映射二级表(secondary tables)</a></span></dt></dl></dd><dt><span class="sect1"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-mapping-query">2.3. 映射查询</a></span></dt><dd><dl><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e1906">2.3.1. 映射EJBQL/HQL查询</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-mapping-query-native">2.3.2. 映射本地化查询</a></span></dt></dl></dd><dt><span class="sect1"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-hibspec">2.4. Hibernate独有的注解扩展</a></span></dt><dd><dl><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-hibspec-entity">2.4.1. 实体</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2195">2.4.2. 标识符</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-hibspec-property">2.4.3. 属性</a></span></dt><dd><dl><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2219">2.4.3.1. 访问类型</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2267">2.4.3.2. 公式</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2276">2.4.3.3. 类型</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2299">2.4.3.4. 索引</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2309">2.4.3.5. @Parent</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2316">2.4.3.6. 生成的属性</a></span></dt></dl></dd><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2341">2.4.4. 继承</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2354">2.4.5. 关于单个关联关系的注解</a></span></dt><dd><dl><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2382">2.4.5.1. 延迟选项和获取模式</a></span></dt></dl></dd><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-hibspec-collection">2.4.6. 关于集合类型的注解</a></span></dt><dd><dl><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2502">2.4.6.1. 参数注解</a></span></dt><dt><span class="sect3"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2530">2.4.6.2. 更多的集合类型</a></span></dt></dl></dd><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2613">2.4.7. 缓存</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2646">2.4.8. 过滤器</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2678">2.4.9. 查询</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#xml-overriding">3. 通过XML覆写元数据</a></span></dt><dd><dl><dt><span class="section"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2735">3.1. 原则</a></span></dt><dd><dl><dt><span class="section"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2742">3.1.1. 全局级别的元数据</a></span></dt><dt><span class="section"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2761">3.1.2. 实体级别的元数据</a></span></dt><dt><span class="section"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2923">3.1.3. 属性级别的元数据</a></span></dt><dt><span class="section"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e2968">3.1.4. 关联级别的元数据</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#validator">4. Hibernate验证器</a></span></dt><dd><dl><dt><span class="sect1"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#validator-constraints">4.1. 约束</a></span></dt><dd><dl><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e3043">4.1.1. 什么是约束？</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e3048">4.1.2. 内建约束</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#validator-constraints-error">4.1.3. 错误信息</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e3208">4.1.4. 编写你自己的约束</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e3262">4.1.5. 注解你的领域模型</a></span></dt></dl></dd><dt><span class="sect1"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e3279">4.2. 使用验证器框架</a></span></dt><dd><dl><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e3284">4.2.1. 数据库schema层次验证</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e3295">4.2.2. Hibernate基于事件的验证</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e3318">4.2.3. 程序级验证</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e3341">4.2.4. 验证信息</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#lucene">5. Hibernate与Lucene集成</a></span></dt><dd><dl><dt><span class="sect1"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#lucene-intro">5.1. 使用Lucene为实体建立索引</a></span></dt><dd><dl><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e3390">5.1.1. 注解领域模型</a></span></dt><dt><span class="sect2"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e3448">5.1.2. 启用自动索引</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#d0e3458">A. 术语表</a></span></dt></dl></div><div class="preface" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>前言</h2></div></div><div></div></div><p>WARNING! This is a translated version of the English Hibernate
    reference documentation. The translated version might not be up to date!
    However, the differences should only be very minor. Consult the English
    reference documentation if you are missing information or encounter a
    translation error. If you like to contribute to a particular translation,
    contact us on the Hibernate developer mailing list.</p><p>Translator(s): RedSaga Translate Team 满江红翻译团队
    &lt;caoxg@yahoo.com&gt;</p><div class="sect1" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="preface-translate-comments-zh-cn"></a>1.&nbsp;翻译说明</h2></div></div><div></div></div><p>本文档的翻译是在网络上协作进行的，也会不断根据Hibernate的升级进行更新。提供此文档的目的是为了减缓学习Hibernate的坡度，而非代替原文档。我们建议所有有能力的读者都直接阅读英文原文。若您对翻译有异议，或发现翻译错误，敬请不吝赐教，报告到如下地址：http://wiki.redsaga.com/confluence/display/HART/Home</p><div class="table"><a name="redsaga-translate-team"></a><p class="title"><b>表&nbsp;1.&nbsp;Hibernate Annotation v3翻译团队</b></p><table summary="Hibernate Annotation v3翻译团队" border="1"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th align="center">序号</th><th align="center">标题</th><th align="center">中文标题</th><th align="center">翻译</th><th align="center">1审</th><th align="center"> 2审</th></tr></thead><tbody><tr><td>--</td><td>Contents</td><td>目录</td><td>Liu Chang</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>#1</td><td>Setting up an annotations projec</td><td>创建一个注解项目</td><td>melthaw</td><td>Zheng Shuai</td><td>superq</td></tr><tr><td>#2</td><td>Entity Beans-Introduction</td><td>实体Bean-简介</td><td>melthaw</td><td>Zheng Shuai</td><td>superq</td></tr><tr><td>#3</td><td>Entity Beans-Mapping with EJB3 Annotations</td><td>实体Bean-用EJB3注解进行映射</td><td>melthaw</td><td>Zheng Shuai</td><td>superq, Liu Chang, Sean Chan</td></tr><tr><td>#4</td><td>Entity Beans-Mapping Queries</td><td>实体Bean-映射查询</td><td>melthaw</td><td>Zheng Shuai</td><td>superq, Liu Chang, Sean Chan</td></tr><tr><td>#5</td><td>Entity Beans-Hibernate Annotation Extensions</td><td>实体Bean-Hibernate独有的注解扩展</td><td>Sean Chan</td><td>morning</td><td>melthaw</td></tr><tr><td>#6</td><td>Overriding metadata through XML</td><td>通过XML覆写元数据</td><td>icess</td><td>melthaw</td><td>Sean Chan</td></tr><tr><td>#7</td><td>Hibernate Validator</td><td>Hibernate验证器</td><td>DigitalSonic</td><td>morning</td><td>melthaw</td></tr><tr><td>#8</td><td>Hibernate Lucene Integration</td><td>Hibernate与Lucene集成</td><td>mochow</td><td>morning</td><td>melthaw</td></tr><tr><td>#9</td><td>Appendix:Glossary</td><td>附录:术语表</td><td>mochow</td><td>Liu Chang</td><td>曹晓钢</td></tr></tbody></table></div><p>关于我们</p><div class="variablelist"><dl><dt><span class="term">满江红.开源, http://www.redsaga.com</span></dt><dd><p>从成立之初就致力于Java开放源代码在中国的传播与发展,与国内多个Java团体及出版社有深入交流。坚持少说多做的原则，目前有两个团队，“OpenDoc团队”与“翻译团队”，本翻译文档即为翻译团队作品。OpenDoc团队已经推出包括Hibernate、iBatis、Spring、WebWork的多份开放文档，并于2005年5月在Hibernate开放文档基础上扩充成书，出版了原创书籍：《深入浅出Hibernate》，本书400余页，适合各个层次的Hibernate用户。(http://www.redsaga.com/hibernate_book.html)敬请支持。</p></dd><dt><span class="term">致谢</span></dt><dd><p>在我们翻译Hibernate
            Annotation参考文档的同时，还有一位热心的朋友也在进行着同样的工作，这位朋友就是icess(冰雨)，由icess翻译的中文版的地址：
            http://icess.my.china.com/hibernate/a/ref/index.htm</p></dd></dl></div></div><div class="sect1" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="preface-translate-licence-zh-cn"></a>2.&nbsp;版权声明</h2></div></div><div></div></div><p>Hibernate英文文档属于Hibernate发行包的一部分，遵循LGPL协议。本翻译版本同样遵循LGPL协议。参与翻译的译者一致同意放弃除署名权外对本翻译版本的其它权利要求。</p><p>您可以自由链接、下载、传播此文档，或者放置在您的网站上，甚至作为产品的一部分发行。但前提是必须保证全文完整转载，包括完整的版权信息和作译者声明，并不能违反LGPL协议。这里“完整”的含义是，不能进行任何删除/增添/注解。若有删除/增添/注解，必须逐段明确声明那些部分并非本文档的一部分。</p></div></div><div class="preface" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title"><a name="d0e199"></a>前言</h2></div></div><div></div></div><p>正如其他的ORM工具,Hibernate同样需要元数据来控制在不同数据表达形式之间的转化. 在Hibernate
    2.x里,多数情况下表示映射关系的元数据保存在XML文本文件中.
    还有一种方式就是Xdoclet,它可以在编译时利用Javadoc中的源码注释信息来进行预处理.
    现在新的JDK标准（JDK1.5以上）也支持类似的注解功能,但相比之下很多工具对此提供了更强大更好用的支持. 以IntelliJ
    IDEA和Eclipse为例,这些IDE工具为JDK 5.0注解功能提供了自动完成和语法高亮功能. 注解被直接编译到字节码里,并
    在运行时（对于Hibernate来讲就是启动的时候）通过反射读取这些注解, 因此外部XML文件就不再需要了.</p><p>EJB3规范最终认可了透明化ORM的成功范例以及市场对于这种技术的兴趣.
    EJB3规范标准化了ORM的基础API而且在任何ORM持久化机制中使用元数据. <span class="emphasis"><em>Hibernate
    EntityManager</em></span>实现了EJB3持久化规范中定义的编程接口和生命周期规则. 在<span class="emphasis"><em>Hibernate
    Core</em></span>的基础上再结合 <span class="emphasis"><em>Hibernate
    Annotations</em></span>就实现了一套完整(并且独立)的EJB3持久化解决方案.
    你可以结合三者来使用,也可以抛开EJB3编程接口和生命周期规则而独立使用注解, 甚至只单独使用<span class="emphasis"><em>Hibernate
    Core</em></span>. 这些都取决于项目的商业和技术上的实际需求. Hibernate允许你直接使用native APIs,如果有需要,
    甚至可以直接操作JDBC和SQL.</p><p>注意本文档基于Hibernate Annotations的预览版(遵从EJB 3.0/JSR-220最终草案).
    这个版本和新规范中定义的最终概念已经非常接近了.我们的目标是提供一套完整的ORM注解,
    包括EJB3的标准注解以及Hibernate3的扩展（后者是EJB3规范中没有涉及到的）. 最终通过注解你可以完成任何可能的映射.详情参考???.</p><p>EJB3最终草案修改了部分注解,
    http://www.hibernate.org/371.html提供了从上一个版本到最新版本的迁移指南.</p></div><div class="chapter" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title"><a name="d0e224"></a>第&nbsp;1&nbsp;章&nbsp;创建一个注解项目</h2></div></div><div></div></div><div class="section" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="setup-requirements"></a>1.1.&nbsp;系统需求</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>首先从Hibernate官方网站下载并解压Hibernate Annotations的发布包。</p></li><li><p><span class="emphasis"><em>这个版本(预览版)要求使用Hibernate 3.2.0.CR2或更高版本。请不要和老版本的Hibernate 3.x混合起来使用。</em></span></p></li><li><p>这个版本在Hibernate core 3.2.0.CR2的基础上工作良好。</p></li><li><p>首先确定你已经安装了JDK 5.0。当然就算使用低版本的JDK，
        Xdoclet也可以提供（基于注解的）元数据所带来的部分功能。
        不过请注意本文档只描述跟JDK5.0注解有关的内容，关于Xdoclet请参考相关文档。</p></li></ul></div></div><div class="section" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="setup-configuration"></a>1.2.&nbsp;系统配置</h2></div></div><div></div></div><p>首先就是设置classpath(当然是在IDE中创建了一个新项目之后)。 </p><div class="itemizedlist"><ul type="disc"><li><p>将Hibernate3核心文件以及其依赖的第三方库文件(请参考lib/README.txt文件)加入到你的classpath里面。</p></li><li><p>将<tt class="filename">hibernate-annotations.jar</tt>
          和<tt class="filename">lib/ejb3-persistence.jar</tt>加入到你的classpath里面。</p></li><li><p>如果要使用 <a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#lucene" title="第 5 章 Hibernate与Lucene集成">第&nbsp;5&nbsp;章 <i>Hibernate与Lucene集成</i></a>，还需要将lucene的jar文件加入你的classpath。</p></li></ul></div><p>我们推荐在一个包装器(wrapper)类<tt class="classname">HibernateUtil</tt>
    的静态初始化代码块中启动Hibernate。或许你在Hibernate文档的其他很多地方看到过这个类，
    但是要在你的项目中使用注解，还需要对这个辅助(helper)类进行扩展。扩展如下:
    </p><pre class="programlisting">package hello;

import org.hibernate.*;
import org.hibernate.cfg.*;
import test.*;
import test.animals.Dog;

public class HibernateUtil {

private static final SessionFactory sessionFactory;

    static {
        try {

            sessionFactory = new <span class="bold"><b>AnnotationConfiguration()</b></span>.buildSessionFactory();
        } catch (Throwable ex) {
            // Log exception!
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static Session getSession()
            throws HibernateException {
        return sessionFactory.openSession();
    }
}
            </pre><p>这里比较有意思的是使用到了<tt class="classname">AnnotationConfiguration</tt>类。
    在XML配置文件(通常是<tt class="filename">hibernate.cfg.xml</tt>)中则定义了包和经过注解的类。下面的xml和前面的声明等价:
    </p><pre class="programlisting">&lt;!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

        &lt;hibernate-configuration&gt;
          &lt;session-factory&gt;
            <span class="bold"><b>&lt;mapping package="test.animals"/&gt;
            &lt;mapping class="test.Flight"/&gt;
            &lt;mapping class="test.Sky"/&gt;
            &lt;mapping class="test.Person"/&gt;
            &lt;mapping class="test.animals.Dog"/&gt;</b></span>
<span class="bold"><b>            &lt;mapping resource="test/animals/orm.xml"/&gt;</b></span>
          &lt;/session-factory&gt;
        &lt;/hibernate-configuration&gt;
        </pre><p>注意现在你可以混合使用hbm.xml和注解。资源元素(resource element)可以是hbm文件也可以是EJB3 XML发布描述符，此差别对于配置过程是透明的。</p><p>除了上面的方式,你还可以通过编程的方式定义包括注解的类和包</p><pre class="programlisting">            sessionFactory = new <span class="bold"><b>AnnotationConfiguration()
                    .addPackage("test.animals") //the fully qualified package name
                    .addAnnotatedClass(Flight.class)
                    .addAnnotatedClass(Sky.class)
                    .addAnnotatedClass(Person.class)
                    .addAnnotatedClass(Dog.class)</b></span>
                    .buildSessionFactory();</pre><p>你也可以使用Hibernate Entity Manager来完成以上功能。Hibernate Entity Manager有自己的一套配置机制，详情请参考相关文档。</p><p>除了启动方式和配置文件有所改变之外，结合注解来使用Hibernate API和以前没有什么区别，
    在其他方面你还是可以继续保持以前的习惯和喜好(<tt class="filename">hibernate.properties</tt>，
    <tt class="filename">hibernate.cfg.xml</tt>， programmatic APIs等等)。
    甚至对于同一个<tt class="classname">SessionFactory</tt>，你都可以混合带注解的持久类以及传统的bm.cfg.xml声明方式。
    然而你不能多次声明同一个类(要么通过注解要么通过hbm.xml配置文件)，
    而且在一个映射实体的类继承层次中，这两个配置策略不能同时使用.
    </p><p>为了简化从hbm文件到注解的迁移过程，
    配置机制将自动检测在注解和hbm文件中重复的映射。
    默认情况下hbm文件中的声明比类中的注解元数据具有更高的优先级。
    这种优先级的设定是以类为单位的。
    你也可以通过<tt class="literal">hibernate.mapping.precedence</tt>修改这种优先级。
    默认的值是<tt class="literal">hbm, class</tt>，
    如果改为<tt class="literal">class,hbm</tt>，当发生冲突的时候，类中的注解将比hbm文件具有更高的优先级。
    </p></div></div><div class="chapter" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title"><a name="entity"></a>第&nbsp;2&nbsp;章&nbsp;实体Bean</h2></div></div><div></div></div><div class="sect1" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="entity-overview"></a>2.1.&nbsp;简介</h2></div></div><div></div></div><p>本章内容覆盖了EJB3.0实体bean的注解规范以及Hibernate特有的扩展.</p></div><div class="sect1" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping"></a>2.2.&nbsp;用EJB3注解进行映射</h2></div></div><div></div></div><p>现在EJB3实体Bean是纯粹的POJO.实际上这表达了和Hibernate持久化实体对象同样的概念.
	它们的映射都通过JDK5.0注解来定义(EJB3规范中的XML描述语法至今还没有最终定下来).
	注解分为两个部分,分别是逻辑映射注解和物理映射注解,
	通过逻辑映射注解可以描述对象模型,类之间的关系等等,
	而物理映射注解则描述了物理的schema,表,列,索引等等.
	下面我们在代码中将混合使用这两种类型的注解.</p><p>EJB3注解的API定义在<tt class="literal">javax.persistence.*</tt>包里面.
	大部分和JDK5兼容的IDE(象Eclipse, IntelliJ IDEA 和Netbeans等等)都提供了注解接口和属性的自动完成功能.
	(这些不需要IDE提供特别的EJB3支持模块,因为EJB3注解是标准的JDK5注解)</p><p>请阅读JBoss EJB 3.0指南或者直接阅读Hibernate Annotations测试代码以获取更多的可运行实例.Hibernate Annotations提供的大部分单元测试代码都演示了实际的例子,是一个获取灵感的好地方.</p><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e346"></a>2.2.1.&nbsp;声明实体bean</h3></div></div><div></div></div><p>每一个持久化POJO类都是一个实体bean,这可以通过在类的定义中使用<tt class="literal">@Entity</tt>注解来进行声明:</p><pre class="programlisting">@Entity
public class Flight implements Serializable {
    Long id;

    @Id
    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }
}
         </pre><p>通过<tt class="literal">@Entity</tt>注解将一个类声明为一个实体bean(即一个持久化POJO类),
	  <tt class="literal">@Id</tt>注解则声明了该实体bean的标识属性.
	  其他的映射定义是隐式的.这种以隐式映射为主体,以显式映射为例外的配置方式在新的EJ3规范中处于非常重要的位置,
	  和以前的版本相比有了质的飞跃.
	  在上面这段代码中：Flight类映射到Flight表,并使用id列作为主键列.
	  </p><p>在对一个类进行注解时,你可以选择对它的的属性或者方法进行注解,根据你的选择,Hibernate的访问类型分别为
	  <tt class="literal">field</tt>或<tt class="literal">property</tt>.
	  EJ3规范要求在需要访问的元素上进行注解声明,例如,如果访问类型为
	  <tt class="literal">property</tt>就要在getter方法上进行注解声明,
	  如果访问类型为 <tt class="literal">field</tt>就要在字段上进行注解声明.应该尽量避免混合使用这两种访问类型.
	  Hibernate根据<tt class="literal">@Id</tt> 或 <tt class="literal">@EmbeddedId</tt>的位置来判断访问类型.</p><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e384"></a>2.2.1.1.&nbsp;定义表(Table)</h4></div></div><div></div></div><p><tt class="literal">@Table</tt>是类一级的注解,
		通过<tt class="literal">@Table</tt>注解可以为实体bean映射指定表(table),目录(catalog)和schema的名字.
		如果没有定义<tt class="literal">@Table</tt>,那么系统自动使用默认值：实体的短类名(不附带包名).</p><pre class="programlisting">@Entity
@Table(name="tbl_sky")
public class Sky implements Serializable {
...
            </pre><p><tt class="literal">@Table</tt>元素包括了一个<tt class="literal">schema</tt>
		和一个 <tt class="literal">catalog</tt>属性,如果需要可以指定相应的值.
		结合使用<tt class="literal">@UniqueConstraint</tt>注解可以定义表的唯一约束(unique constraint)
		(对于绑定到单列的唯一约束,请参考<tt class="literal">@Column</tt>注解)
		</p><pre class="programlisting">@Table(name="tbl_sky",
		    <span class="bold"><b>uniqueConstraints = {@UniqueConstraint(columnNames={"month", "day"})}</b></span>
		)</pre><p>上面这个例子中,在month和day这两个字段上定义唯一约束.
		注意<tt class="literal">columnNames</tt>数组中的值指的是逻辑列名.</p><i><span class="remark">Hibernate在NamingStrategy的实现中定义了逻辑列名.
		默认的EJB3命名策略将物理字段名当作逻辑字段名来使用.
		注意该字段名和它对应的属性名可能不同(如果字段名是显式指定的话).
		除非你重写了NamingStrategy,否则不用担心这些区别..</span></i></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e427"></a>2.2.1.2.&nbsp;乐观锁定版本控制</h4></div></div><div></div></div><p>你可以在实体bean中使用<tt class="literal">@Version</tt>注解,通过这种方式可添加对乐观锁定的支持:</p><pre class="programlisting">@Entity
public class Flight implements Serializable {
...
    @Version
    @Column(name="OPTLOCK")
    public Integer getVersion() { ... }
}           </pre><p>上面这个例子中,version属性将映射到 <tt class="literal">OPTLOCK</tt>列,
		entity manager使用该字段来检测更新冲突(防止更新丢失,请参考last-commit-wins策略).</p><p>根据EJB3规范,version列可以是numeric类型(推荐方式)也可以是timestamp类型.
		Hibernate支持任何自定义类型,只要该类型实现了<tt class="classname">UserVersionType</tt>.</p></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e447"></a>2.2.2.&nbsp;映射简单属性</h3></div></div><div></div></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e450"></a>2.2.2.1.&nbsp;声明基本的属性映射</h4></div></div><div></div></div><p>Every non static non transient property (field or method) of an
        entity bean is considered persistent, unless you annotate it as
        <tt class="literal">@Transient</tt>. Not having an annotation for your
        property is equivalent to the appropriate <tt class="literal">@Basic</tt>
        annotation. The <tt class="literal">@Basic</tt> annotation allows you to
        declare the fetching strategy for a property:</p><p>实体bean中所有的非static非transient的属性都可以被持久化,
		除非你将其注解为<tt class="literal">@Transient</tt>.所有没有定义注解的属性等价于在其上面添加了@Basic注解.
		通过 <tt class="literal">@Basic</tt>注解可以声明属性的获取策略(fetch strategy)：</p><pre class="programlisting">public transient int counter; //transient property

private String firstname; //persistent property

@Transient
String getLengthInMeter() { ... } //transient property

String getName() {... } // persistent property

@Basic
int getLength() { ... } // persistent property

@Basic(fetch = FetchType.LAZY)
String getDetailedComment() { ... } // persistent property

@Temporal(TemporalType.TIME)
java.util.Date getDepartureTime() { ... } // persistent property           

@Enumerated(EnumType.STRING)
Starred getNote() { ... } //enum persisted as String in database</pre><p>上面这个例子中,<tt class="literal">counter</tt>是一个transient的字段,
		<tt class="literal">lengthInMeter</tt>的getter方法被注解为<tt class="literal">@Transient</tt>, 
		entity manager将忽略这些字段和属性.
		而<tt class="literal">name</tt>,<tt class="literal">length</tt>,<tt class="literal">firstname</tt>
		这几个属性则是被定义为可持久化和可获取的.对于简单属性来说,默认的获取方式是即时获取(early fetch).
		当一个实体Bean的实例被创建时,Hibernate会将这些属性的值从数据库中提取出来,保存到Bean的属性里.
		与即时获取相对应的是延迟获取(lazy fetch).如果一个属性的获取方式是延迟获取
		(比如上面例子中的<tt class="literal">detailedComment</tt>属性),
		Hibernate在创建一个实体Bean的实例时,不会即时将这个属性的值从数据库中读出.
		只有在该实体Bean的这个属性第一次被调用时,Hibernate才会去获取对应的值.
		通常你不需要对简单属性设置延迟获取(lazy simple property),千万不要和延迟关联获取(lazy association fetch)混淆了
		(译注:这里指不要把lazy simple property和lazy association fetch混淆了).
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>为了启用属性级的延迟获取,你的类必须经过特殊处理(instrumented)：
		  字节码将被织入原始类中来实现延迟获取功能,
		  详情参考Hibernate参考文档.如果不对类文件进行字节码特殊处理,
		  那么属性级的延迟获取将被忽略.</p></div><p>推荐的替代方案是使用EJB-QL或者Criteria查询的投影(projection)功能.</p><p>Hibernate和EJB3都支持所有基本类型的属性映射.
		这些基本类型包括所有的Java基本类型,及其各自的wrapper类和serializable类.
		Hibernate Annotations还支持将内置的枚举类型映射到一个顺序列(保存了相应的序列值)
		或一个字符串类型的列(保存相应的字符串).默认是保存枚举的序列值,
		但是你可以通过<tt class="literal">@Enumerated</tt>注解来进行调整(见上面例子中的note属性).</p><p>在核心的Java API中并没有定义时间精度(temporal precision).
		因此处理时间类型数据时,你还需要定义将其存储在数据库中所预期的精度.
		在数据库中,表示时间类型的数据有<tt class="literal">DATE</tt>, <tt class="literal">TIME</tt>, 
		和 <tt class="literal">TIMESTAMP</tt>三种精度(即单纯的日期,时间,或者两者兼备).
		可使用<tt class="literal">@Temporal</tt>注解来调整精度.</p><p><tt class="literal">@Lob</tt>注解表示属性将被持久化为Blob或者Clob类型,
		具体取决于属性的类型,
		<tt class="classname">java.sql.Clob</tt>, 
		<tt class="classname">Character[]</tt>,
		<tt class="classname">char[]</tt> 和 
		<tt class="classname">java.lang.String</tt>这些类型的属性都被持久化为Clob类型,
		而<tt class="classname">java.sql.Blob</tt>, 
		<tt class="classname">Byte[]</tt>, 
		<tt class="classname">byte[]</tt> 和
		serializable类型则被持久化为Blob类型.</p><pre class="programlisting">@Lob
public String getFullText() {
    return fullText;
}

@Lob 
public byte[] getFullCode() {
    return fullCode;
}
 </pre><p>如果某个属性实现了<tt class="classname">java.io.Serializable</tt>同时也不是基本类型,
		并且没有在该属性上使用<tt class="literal">@Lob</tt>注解,
		那么Hibernate将使用自带的<tt class="literal">serializable</tt>类型.
		</p></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e559"></a>2.2.2.2.&nbsp;声明列属性</h4></div></div><div></div></div><p>使用 <tt class="literal">@Column </tt>注解可将属性映射到列.
		使用该注解来覆盖默认值(关于默认值请参考EJB3规范).
		在属性级使用该注解的方式如下：</p><div class="itemizedlist"><ul type="disc"><li><p>不进行注解</p></li><li><p>和 <tt class="literal">@Basic</tt>一起使用</p></li><li><p>和 <tt class="literal">@Version</tt>一起使用</p></li><li><p>和 <tt class="literal">@Lob</tt>一起使用</p></li><li><p>和 <tt class="literal">@Temporal</tt>一起使用</p></li><li><p>和
            <tt class="literal">@org.hibernate.annotations.CollectionOfElements</tt>一起使用
            (只针对Hibernate )</p></li></ul></div><pre class="programlisting">@Entity
public class Flight implements Serializable {
...
@Column(updatable = false, name = "flight_name", nullable = false, length=50)
public String getName() { ... }
            </pre><p>在上面这个例子中,<tt class="literal">name</tt>属性映射到<tt class="literal">flight_name</tt>列.
		该字段不允许为空,长度为50,并且是不可更新的(也就是属性值是不变的).</p><p>上面这些注解可以被应用到正规属性上例如<tt class="literal">@Id</tt> 或<tt class="literal">@Version</tt>属性.</p><div class="programlistingco"><pre class="programlisting">@Column(
    name="columnName";                                <span class="co">(1)</span>
    boolean unique() default false;                   <span class="co">(2)</span>
    boolean nullable() default true;                  <span class="co">(3)</span>
    boolean insertable() default true;                <span class="co">(4)</span>
    boolean updatable() default true;                 <span class="co">(5)</span>
    String columnDefinition() default "";             <span class="co">(6)</span>
    String table() default "";                        <span class="co">(7)</span>
    int length() default 255;                         <span class="co">(8)</span>
    int precision() default 0; // decimal precision   <span class="co">(9)</span>
    int scale() default 0; // decimal scale</pre><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p><tt class="literal">name</tt> 可选,列名(默认值是属性名)</p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p><tt class="literal">unique</tt> 可选,是否在该列上设置唯一约束(默认值false)</p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p><tt class="literal">nullable</tt> 可选,是否设置该列的值可以为空(默认值false)</p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p><tt class="literal">insertable</tt> 可选,该列是否作为生成的insert语句中的一个列(默认值true)</p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p><tt class="literal">updatable</tt> 可选,该列是否作为生成的update语句中的一个列(默认值true)</p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p><tt class="literal">columnDefinition</tt> 可选: 为这个特定列覆盖SQL DDL片段 (这可能导致无法在不同数据库间移植)</p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p><tt class="literal">table</tt> 可选,定义对应的表(默认为主表)</p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p><tt class="literal"><tt class="literal">length</tt></tt> 可选,列长度(默认值255)</p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p><tt class="literal"><tt class="literal">precision</tt></tt>
              可选,列十进制精度(decimal precision)(默认值0)</p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p><tt class="literal"><tt class="literal">scale</tt></tt> 
              可选,如果列十进制数值范围(decimal scale)可用,在此设置(默认值0)</p></td></tr></tbody></table></div></div></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e687"></a>2.2.2.3.&nbsp;嵌入式对象(又名组件)</h4></div></div><div></div></div><p>在实体中可以定义一个嵌入式组件(embedded component),
		甚至覆盖该实体中原有的列映射.
		组件类必须在类一级定义<tt class="literal">@Embeddable</tt>注解.
		在特定的实体的关联属性上使用<tt class="literal">@Embedded</tt>和
		<tt class="literal">@AttributeOverride</tt>注解可以覆盖该属性对应的嵌入式对象的列映射：</p><pre class="programlisting">@Entity
public class Person implements Serializable {

    // Persistent component using defaults
    Address homeAddress;

    @Embedded
    @AttributeOverrides( {
            @AttributeOverride(name="iso2", column = @Column(name="bornIso2") ),
            @AttributeOverride(name="name", column = @Column(name="bornCountryName") )
    } )
    Country bornIn;
    ...
}
            </pre><pre class="programlisting">@Embeddable
public class Address implements Serializable {
    String city;
    Country nationality; //no overriding here
}
            </pre><pre class="programlisting">@Embeddable
public class Country implements Serializable {
    private String iso2;
    @Column(name="countryName") private String name;

    public String getIso2() { return iso2; }
    public void setIso2(String iso2) { this.iso2 = iso2; }

    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    ...
}
            </pre><p>嵌入式对象继承其所属实体中定义的访问类型
		(注意:这可以通过使用Hibernate提供的<tt class="literal">@AccessType</tt>注解来覆盖原有值)(请参考 <a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-hibspec">Hibernate Annotation Extensions</a>).</p><p>在上面的例子中,实体bean <tt class="literal">Person</tt> 有两个组件属性,
		分别是<tt class="literal">homeAddress</tt>和<tt class="literal">bornIn</tt>. 
		我们可以看到<tt class="literal">homeAddress</tt> 属性并没有注解.
		但是Hibernate自动检测其对应的Address类中的<tt class="literal">@Embeddable</tt>注解,
		并将其看作一个持久化组件.对于Country中已映射的属性,
		则使用<tt class="literal">@Embedded</tt>和<tt class="literal">@AttributeOverride
        </tt>注解来覆盖原来映射的列名.
		正如你所看到的, <tt class="literal">Address</tt>对象中还内嵌了<tt class="literal">Country</tt>对象,
		这里和<tt class="literal">homeAddress</tt>一样使用了Hibernate和EJB3自动检测机制.
		目前EJB3规范还不支持覆盖多层嵌套(即嵌入式对象中还包括其他嵌入式对象)的列映射.
		不过Hibernate通过在表达式中使用"."符号表达式提供了对此特征的支持.</p><pre class="programlisting">    @Embedded
    @AttributeOverrides( {
            @AttributeOverride(name="city", column = @Column(name="fld_city") ),
            @AttributeOverride(name="<span class="bold"><b>nationality.iso2</b></span>", column = @Column(name="nat_Iso2") ),
            @AttributeOverride(name="<span class="bold"><b>nationality.name</b></span>", column = @Column(name="nat_CountryName") )
            //nationality columns in homeAddress are overridden
    } )
    Address homeAddress;</pre><p>
	Hibernate注解支持很多EJB3规范中没有明确定义的特性.
	例如,可以在嵌入式对象上添加 <tt class="literal">@MappedSuperclass</tt>注解,
	这样可以将其父类的属性持久(详情请查阅<tt class="literal">@MappedSuperclass</tt>).</p><p>Hibernate现在支持在嵌入式对象中使用关联注解(如<tt class="literal">@*ToOne</tt>和<tt class="literal">@*ToMany</tt>).
		而EJB3规范尚不支持这样的用法。你可以使用 <tt class="literal">@AssociationOverride</tt>注解来覆写关联列.</p><p>在同一个实体中使用两个同类型的嵌入对象,
		其默认列名是无效的:至少要对其中一个进行明确声明.
		Hibernate在这方面走在了EJB3规范的前面,
		Hibernate提供了<tt class="classname">NamingStrategy</tt>, 在使用Hibernate时, 
		通过<tt class="classname">NamingStrategy</tt>你可以对默认的机制进行扩展. 
		<tt class="classname">DefaultComponentSafeNamingStrategy</tt>
		在默认的EJB3NamingStrategy上进行了小小的提升,
		允许在同一实体中使用两个同类型的嵌入对象而无须额外的声明.</p></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e784"></a>2.2.2.4.&nbsp;无注解之属性的默认值</h4></div></div><div></div></div><p>如果某属性没有注解,该属性将遵守下面的规则:</p><div class="itemizedlist"><ul type="disc"><li>
             如果属性为单一类型,则映射为@Basic 
          </li><li>
             否则,如果属性对应的类型定义了@Embeddable注解,则映射为@Embedded 
          </li><li>
             否则,如果属性对应的类型实现了Serializable,
			 则属性被映射为@Basic并在一个列中保存该对象的serialized版本
          </li><li>
            否则,如果该属性的类型为java.sql.Clob 或 java.sql.Blob,则作为@Lob并映射到适当的LobType.
          </li></ul></div></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-identifier"></a>2.2..&nbsp;映射主键属性</h3></div></div><div></div></div><p>使用<tt class="literal">@Id</tt>注解可以将实体bean中的某个属性定义为标识符(identifier).
	  该属性的值可以通过应用自身进行设置,
	  也可以通过Hiberante生成(推荐).
	  使用 <tt class="literal">@GeneratedValue</tt>注解可以定义该标识符的生成策略:
	  </p><div class="itemizedlist"><ul type="disc"><li>
           AUTO - 可以是identity column类型,或者sequence类型或者table类型,取决于不同的底层数据库. 
        </li><li>
           TABLE - 使用表保存id值
        </li><li>
           IDENTITY - identity column
        </li><li>
           SEQUENCE - sequence 
        </li></ul></div><p>和EJB3规范相比,Hibernate提供了更多的id生成器.详情请查阅 <a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-hibspec">Hibernate Annotation Extensions</a> .</p><p>下面的例子展示了使用SEQ_STORE配置的sequence生成器</p><pre class="programlisting">@Id @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="SEQ_STORE")
public Integer getId() { ... }
         </pre><p>下面这个例子使用的是identity生成器</p><pre class="programlisting">@Id @GeneratedValue(strategy=GenerationType.IDENTITY)
public Long getId() { ... }
         </pre><p><tt class="literal">AUTO</tt>生成器适用于可移植的应用(在多个DB间切换).
	  多个<tt class="literal">@Id</tt>可以共享同一个identifier生成器,只要把generator属性设成相同的值就可以了.
	  通过<tt class="literal">@SequenceGenerator</tt> 和<tt class="literal">@TableGenerator</tt>,你可以配置不同的identifier生成器. 
	  每一个identifier生成器都有自己的适用范围,可以是应用级(application level)和类一级(class level). 
	  类一级的生成器在外部是不可见的,
	  而且类一级的生成器可以覆盖应用级的生成器.
	  应用级的生成器则定义在包一级(package level)(如<tt class="classname">package-info.java</tt>):</p><pre class="programlisting">@javax.persistence.TableGenerator(
    name="EMP_GEN",
    table="GENERATOR_TABLE",
    pkColumnName = "key",
    valueColumnName = "hi"
    pkColumnValue="EMP",
    allocationSize=20
)
@javax.persistence.SequenceGenerator(
    name="SEQ_GEN",
    sequenceName="my_sequence"
)
package org.hibernate.test.metadata;
         </pre><p>
	  如果在<tt class="classname">org.hibernate.test.metadata</tt>包下面的
	  <tt class="classname">package-info.java</tt>文件用于初始化EJB配置,
	  那么该文件中定义的 <tt class="literal">EMP_GEN</tt>
	  和<tt class="literal">SEQ_GEN</tt>都是应用级的生成器. 
      <tt class="literal">EMP_GEN</tt>定义了一个使用hilo算法
	  (max_lo为20)的id生成器(该生成器将id的信息存在数据库的某个表中.).
	  id的hi值保存在<tt class="literal">GENERATOR_TABLE</tt>中.
      在该表中 <tt class="literal">pkColumnName</tt>"key"等价于
	  <tt class="literal">pkColumnValue</tt> "<tt class="literal">EMP</tt>",
      而<tt class="literal">valueColumnName</tt> "<tt class="literal">hi</tt>"中存储的是下一个要使用的最大值.
	  </p><p><tt class="literal">SEQ_GEN</tt>则定义了一个sequence 生成器,
	  其对应的sequence名为 <tt class="literal">my_sequence</tt>.
	  注意目前Hibernate Annotations还不支持sequence 生成器中的
	  <tt class="literal">initialValue</tt>和 <tt class="literal">allocationSize</tt>参数.</p><p>下面这个例子展示了定义在类范围(class scope)的sequence生成器:</p><pre class="programlisting">@Entity
@javax.persistence.SequenceGenerator(
    name="SEQ_STORE",
    sequenceName="my_sequence"
)
public class Store implements Serializable {
    private Long id;

    @Id @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="SEQ_STORE")
    public Long getId() { return id; }
}
         </pre><p>在这个例子中,Store类使用名为my_sequence的sequence,并且SEQ_STORE 生成器对于其他类是不可见的.
      注意在org.hibernate.test.metadata.id包下的测试代码有更多演示Hibernate Annotations用法的例子..</p><p>下面是定义组合主键的几种语法:</p><div class="itemizedlist"><ul type="disc"><li>
           将组件类注解为@Embeddable,并将组件的属性注解为@Id
        </li><li>
           将组件的属性注解为@EmbeddedId
        </li><li>
           将类注解为@IdClass,并将该实体中所有属于主键的属性都注解为@Id 
        </li></ul></div><p>对于EJB2的开发人员来说 <tt class="literal">@IdClass</tt>是很常见的,
	  但是对于Hibernate的用户来说就是一个崭新的用法.
	  组合主键类对应了一个实体类中的多个字段或属性,
	  而且主键类中用于定义主键的字段或属性和
	  实体类中对应的字段或属性在类型上必须一致.下面我们看一个例子:</p><pre class="programlisting">@Entity
<span class="bold"><b>@IdClass(FootballerPk.class)</b></span>
public class Footballer {
    //part of the id key
    <span class="bold"><b>@Id</b></span> public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    //part of the id key
    <span class="bold"><b>@Id</b></span> public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }

    public String getClub() {
        return club;
    }

    public void setClub(String club) {
        this.club = club;
    }

    //appropriate equals() and hashCode() implementation
}

@Embeddable
public class FootballerPk implements Serializable {
    //same name and type as in Footballer
    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    //same name and type as in Footballer
    public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }

    //appropriate equals() and hashCode() implementation
}
</pre><p>如上, <tt class="literal">@IdClass</tt>指向对应的主键类.</p><p>Hibernate支持在组合标识符中定义关联(就像使用普通的注解一样),而EJB3规范并不支持此类用法.
	  </p><pre class="programlisting">@Entity
@AssociationOverride( name="id.channel", joinColumns = @JoinColumn(name="chan_id") )
public class TvMagazin {
    @EmbeddedId public TvMagazinPk id;
    @Temporal(TemporalType.TIME) Date time;
}

@Embeddable
public class TvMagazinPk implements Serializable {
    @ManyToOne
    public Channel channel;
    public String name;
    @ManyToOne
    public Presenter presenter;
}
</pre></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e936"></a>2.2.4.&nbsp;映射继承关系</h3></div></div><div></div></div><p>EJB3支持三种类型的继承映射:</p><div class="itemizedlist"><ul type="disc"><li>
            每个类一张表(Table per class)策略: 在Hibernate中对应&lt;union-class&gt;元素:
        </li><li>
		   每个类层次结构一张表(Single table per class hierarchy)策略:在Hibernate中对应&lt;subclass&gt;元素
        </li><li>
		   连接的子类(Joined subclasses)策略:在Hibernate中对应 &lt;joined-subclass&gt;元素
        </li></ul></div><p>
      你可以用 <tt class="literal">@Inheritance</tt>注解来定义所选择的策略.
      这个注解需要在每个类层次结构(class hierarchy) 最顶端的实体类上使用.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>目前还不支持在接口上进行注解.</p></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e956"></a>2.2.4.1.&nbsp;每个类一张表</h4></div></div><div></div></div><p>
		这种策略有很多缺点(例如:多态查询和关联),EJB3规范, Hibernate参考手册, 
		Hibernate in Action,以及其他许多地方都对此进行了描述和解释.
		Hibernate使用<tt class="literal">SQL UNION</tt>查询来实现这种策略.
		通常使用场合是在一个继承层次结构的顶端:</p><pre class="programlisting">@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public class Flight implements Serializable {
            </pre><p>
		这种策略支持双向的一对多关联.
		这里不支持<tt class="literal">IDENTITY</tt>生成器策略,因为id必须在多个表间共享.
		当然,一旦使用这种策略就意味着你不能使用
		<tt class="literal">AUTO </tt>生成器和<tt class="literal">IDENTITY</tt>生成器.
		</p></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e977"></a>2.2.4.2.&nbsp;每个类层次结构一张表</h4></div></div><div></div></div><p>整个继承层次结构中的父类和子类的所有属性都映射到同一个表中,
		他们的实例通过一个辨别符(discriminator)列来区分.:</p><pre class="programlisting">@Entity
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(
    name="planetype",
    discriminatorType=DiscriminatorType.STRING
)
@DiscriminatorValue("Plane")
public class Plane { ... }

@Entity
@DiscriminatorValue("A320")
public class A320 extends Plane { ... }
            </pre><p>在上面这个例子中,<tt class="classname">Plane</tt>是父类,在这个类里面将继承策略定义为
		<tt class="literal">InheritanceType.SINGLE_TABLE</tt>,并通过
		<tt class="literal">@DiscriminatorColumn</tt>注解定义了辨别符列(还可以定义辨别符的类型).
		最后,对于继承层次结构中的每个类,<tt class="literal">@DiscriminatorValue</tt>注解指定了用来辨别该类的值.
		辨别符列的名字默认为 <tt class="literal">DTYPE</tt>,其默认值为实体名(在<tt class="literal">@Entity.name</tt>中定义)，其类型
		为DiscriminatorType.STRING.
		 <tt class="classname">A320</tt>是子类,如果不想使用默认的辨别符,只需要指定相应的值即可.
		其他的如继承策略,辨别标志字段的类型都是自动设定的.</p><p><tt class="literal">@Inheritance</tt> 和
        <tt class="literal">@DiscriminatorColumn</tt> 注解只能用于实体层次结构的顶端.</p></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1014"></a>2.2.4.3.&nbsp;连接的子类</h4></div></div><div></div></div><p>当每个子类映射到一个表时, <tt class="literal"> @PrimaryKeyJoinColumn</tt>
		和<tt class="literal">@PrimaryKeyJoinColumns</tt>
		注解定义了每个子类表关联到父类表的主键:</p><pre class="programlisting">@Entity
@Inheritance(strategy=InheritanceType.JOINED)
public class Boat implements Serializable { ... }

@Entity
public class Ferry extends Boat { ... }

@Entity
@PrimaryKeyJoinColumn(name="BOAT_ID")
public class AmericaCupClass  extends Boat { ... }
            </pre><p>以上所有实体都使用了<tt class="literal">JOINED</tt>策略, 
		<tt class="literal">Ferry</tt>表和<tt class="literal">Boat</tt>表使用同名的主键.
		而<tt class="literal">AmericaCupClass</tt>表和<tt class="literal">Boat</tt>表使用了条件
		<tt class="code">Boat.id = AmericaCupClass.BOAT_ID</tt>进行关联.
		</p></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1047"></a>2.2.4.4.&nbsp;从父类继承的属性</h4></div></div><div></div></div><p>有时候通过一个(技术上或业务上)父类共享一些公共属性是很有用的,
		同时还不用将该父类作为映射的实体(也就是该实体没有对应的表).
		这个时候你需要使用<tt class="literal">@MappedSuperclass</tt>注解来进行映射.</p><pre class="programlisting">@MappedSuperclass
public class BaseEntity {
    @Basic
    @Temporal(TemporalType.TIMESTAMP)
    public Date getLastUpdate() { ... }
    public String getLastUpdater() { ... }
    ...
}

@Entity class Order extends BaseEntity {
    @Id public Integer getId() { ... }
    ...
}</pre><p>在数据库中,上面这个例子中的继承的层次结构最终以<tt class="literal">Order</tt>表的形式出现,
		该表拥有<tt class="literal">id</tt>, <tt class="literal">lastUpdate</tt> 和
		<tt class="literal">lastUpdater</tt>三个列.父类中的属性映射将复制到其子类实体.
		注意这种情况下的父类不再处在继承层次结构的顶端.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>注意,没有注解为<tt class="literal">@MappedSuperclass</tt>的父类中的属性将被忽略.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>除非显式使用Hibernate annotation中的<tt class="literal">@AccessType</tt>注解,
		  否则将从继承层次结构的根实体中继承访问类型(包括字段或方法)</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>这对于<tt class="literal">@Embeddable</tt>对象的父类中的属性持久化同样有效.
		  只需要使用<tt class="literal">@MappedSuperclass</tt>注解即可
		  (虽然这种方式不会纳入EJB3标准)</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>可以将处在在映射继承层次结构的中间位置的类注解为<tt class="literal">@MappedSuperclass</tt>.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>在继承层次结构中任何没有被注解为<tt class="literal">@MappedSuperclass</tt>
		  或<tt class="literal">@Entity</tt>的类都将被忽略.</p></div><p>
		你可以通过 <tt class="literal">@AttributeOverride</tt>注解覆盖实体父类中的定义的列.
		这个注解只能在继承层次结构的顶端使用.</p><pre class="programlisting">@MappedSuperclass
public class FlyingObject implements Serializable {

    public int getAltitude() {
        return altitude;
    }

    @Transient
    public int getMetricAltitude() {
        return metricAltitude;
    }

    @ManyToOne
    public PropulsionType getPropulsion() {
        return metricAltitude;
    }
    ...
}

@Entity
@AttributeOverride( name="altitude", column = @Column(name="fld_altitude") )
@AssociationOverride( name="propulsion", joinColumns = @JoinColumn(name="fld_propulsion_fk") )
public class Plane extends FlyingObject {
    ...
}</pre><p>在上面这个例子中,<tt class="literal">altitude</tt>属性的值最终将持久化到<tt class="literal">Plane</tt>
		表的<tt class="literal">fld_altitude</tt>列.而名为propulsion的关联则保存在<tt class="literal">fld_propulsion_fk</tt>外间列.</p><p>你可以为<tt class="literal">@Entity</tt>和<tt class="literal">@MappedSuperclass</tt>注解的类
		以及那些对象为<tt class="literal">@Embeddable</tt>的属性定义
		<tt class="literal">@AttributeOverride</tt>和<tt class="literal">@AssociationOverride</tt>.</p></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="entity-mapping-association"></a>2.2.5.&nbsp;映射实体Bean的关联关系</h3></div></div><div></div></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1148"></a>2.2.5.1.&nbsp;一对一(One-to-one)</h4></div></div><div></div></div><p>使用<tt class="literal">@OneToOne</tt>注解可以建立实体bean之间的一对一的关联.
		一对一关联有三种情况：
		一是关联的实体都共享同样的主键,
		二是其中一个实体通过外键关联到另一个实体的主键
		(注意要模拟一对一关联必须在外键列上添加唯一约束).
		三是通过关联表来保存两个实体之间的连接关系
		(注意要模拟一对一关联必须在每一个外键上添加唯一约束).</p><p>首先,我们通过共享主键来进行一对一关联映射:</p><pre class="programlisting">@Entity
public class Body {
    @Id
    public Long getId() { return id; }

    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    public Heart getHeart() {
        return heart;
    }
    ...
}
            </pre><pre class="programlisting">@Entity
public class Heart {
    @Id
    public Long getId() { ...}
}
            </pre><p>上面的例子通过使用注解<tt class="literal">@PrimaryKeyJoinColumn</tt>定义了一对一关联.</p><p>下面这个例子使用外键列进行实体的关联.</p><pre class="programlisting">@Entity
public class Customer implements Serializable {
    @OneToOne(cascade = CascadeType.ALL)
    <span class="bold"><b>@JoinColumn(name="passport_fk")</b></span>
    public Passport getPassport() {
        ...
    }

@Entity
public class Passport implements Serializable {
    @OneToOne(<span class="bold"><b>mappedBy = "passport"</b></span>)
    public Customer getOwner() {
    ...
}
            </pre><p>上面这个例子中,<tt class="classname">Customer</tt> 通过<tt class="literal">Customer</tt>
		表中名为的<tt class="literal">passport_fk</tt> 外键列和 <tt class="classname">Passport</tt>关联.
		<tt class="literal">@JoinColumn</tt>注解定义了联接列(join column).
		该注解和<tt class="literal">@Column</tt>注解有点类似,
		但是多了一个名为<tt class="literal">referencedColumnName</tt>的参数.
		该参数定义了所关联目标实体中的联接列.
		注意,当<tt class="literal"><tt class="literal">referencedColumnName</tt></tt>关联到非主键列的时候,
		关联的目标类必须实现<tt class="classname">Serializable</tt>,
		还要注意的是所映射的属性对应单个列(否则映射无效).
		</p><p>一对一关联可能是双向的.在双向关联中,
		有且仅有一端是作为主体(owner)端存在的：主体端负责维护联接列(即更新).
		对于不需要维护这种关系的从表则通过mappedBy属性进行声明.
		<tt class="literal">mappedBy</tt>的值指向主体的关联属性.
		在上面这个例子中,<tt class="literal">mappedBy</tt>的值为 <tt class="literal">passport</tt>.
		最后,不必也不能再在被关联端(owned side)定义联接列了,因为已经在主体端进行了声明.</p><p>如果在主体没有声明<tt class="literal">@JoinColumn</tt>,系统自动进行处理：
		在主表(owner table)中将创建联接列,
		列名为：主体的关联属性名＋下划线＋被关联端的主键列名.
		在上面这个例子中是<tt class="literal">passport_id</tt>,
		因为<tt class="literal">Customer</tt>中关联属性名为<tt class="literal">passport</tt>,
		<tt class="literal">Passport</tt>的主键是<tt class="literal">id</tt>.</p><p>The third possibility (using an association table) is very
        exotic.</p><p>第三种方式也许是最另类的(通过关联表).</p><pre class="programlisting">@Entity
public class Customer implements Serializable {
    @OneToOne(cascade = CascadeType.ALL)
    <span class="bold"><b>@JoinTable(name = "CustomerPassports",
        joinColumns = @JoinColumn(name="customer_fk"),
        inverseJoinColumns = @JoinColumn(name="passport_fk")</b></span>
    )
    public Passport getPassport() {
        ...
    }

@Entity
public class Passport implements Serializable {
    @OneToOne(<span class="bold"><b>mappedBy = "passport"</b></span>)
    public Customer getOwner() {
    ...
}
            </pre><p><tt class="classname">Customer</tt>通过名为 <tt class="literal">CustomerPassports</tt>的关联表和
        <tt class="classname">Passport</tt>关联; 该关联表拥有名为<tt class="literal">passport_fk</tt>的外键列,该
		外键指向<tt class="literal">Passport</tt>表,该信息定义为<tt class="literal">inverseJoinColumn</tt>的属性值,
		而<tt class="literal">customer_fk</tt>外键列指向<tt class="literal">Customer</tt>表,
		该信息定义为 <tt class="literal">joinColumns</tt>的属性值.</p><p>这种关联可能是双向的.在双向关联中,
		有且仅有一端是作为主体端存在的：主体端负责维护联接列(即更新).
		对于不需要维护这种关系的从表则通过mappedBy属性进行声明.
		<tt class="literal">mappedBy</tt>的值指向主体的关联属性.
		在上面这个例子中,<tt class="literal">mappedBy</tt>的值为 <tt class="literal">passport</tt>.
		最后,不必也不能再在被关联端(owned side)定义联接列了,因为已经在主体端进行了声明.</p><p>你必须明确定义关联表名和关联列名.</p></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1291"></a>2.2.5.2.&nbsp;多对一(Many-to-one)</h4></div></div><div></div></div><p>在实体属性一级使用<tt class="literal">@ManyToOne</tt>注解来定义多对一关联:</p><pre class="programlisting">@Entity()
public class Flight implements Serializable {
    <span class="bold"><b>@ManyToOne</b></span>( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )
    @JoinColumn(name="COMP_ID")
    public Company getCompany() {
        return company;
    }
    ...
}
            </pre><p>其中<tt class="literal">@JoinColumn</tt>是可选的,关联字段默认值和一对一
		(one to one)关联的情况相似,
		列名为：主体的关联属性名＋下划线＋被关联端的主键列名.
		在这个例子中是<tt class="literal">company_id</tt>,
		因为关联的属性是<tt class="literal">company</tt>,
		<tt class="literal">Company</tt>的主键是<tt class="literal">id</tt>.</p><p><tt class="literal">@ManyToOne</tt>注解有一个名为<tt class="literal">targetEntity</tt>的参数,
		该参数定义了目标实体名.通常不需要定义该参数,
		因为在大部分情况下默认值(表示关联关系的属性类型)就可以很好的满足要求了.
		不过下面这种情况下这个参数就显得有意义了：使用接口作为返回值而不是常见的实体.</p><pre class="programlisting">@Entity()
public class Flight implements Serializable {
    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE}, <span class="bold"><b>targetEntity=CompanyImpl.class</b></span> )
    @JoinColumn(name="COMP_ID")
    public Company getCompany() {
        return company;
    }
    ...
}

public interface Company {
    ...
            </pre><p>对于多对一也可以通过关联表的方式来映射。
		通过<tt class="literal">@JoinTable</tt>注解可定义关联表，
		该关联表包含了指回实体表的外键(通过<tt class="literal">@JoinTable.joinColumns</tt>)
		以及指向目标实体表的外键(通过<tt class="literal">@JoinTable.inverseJoinColumns</tt>).</p><pre class="programlisting">@Entity()
public class Flight implements Serializable {
    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )
    <span class="bold"><b>@JoinTable(name="Flight_Company",
        joinColumns = @JoinColumn(name="FLIGHT_ID"),
        inverseJoinColumns = @JoinColumn(name="COMP_ID")
    )</b></span>
    public Company getCompany() {
        return company;
    }
    ...
}
            </pre></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="entity-mapping-association-collections"></a>2.2.5.3.&nbsp;集合类型</h4></div></div><div></div></div><div class="sect4" lang="zh_cn"><div class="titlepage"><div><div><h5 class="title"><a name="d0e1352"></a>2.2.5.3.1.&nbsp;概况</h5></div></div><div></div></div><p>你可以对 <tt class="classname">Collection </tt>,<tt class="literal">List</tt>
		  (指有序列表, 而不是索引列表),
		  <tt class="literal">Map</tt>和<tt class="classname">Set</tt>这几种类型进行映射.
		  EJB3规范定义了怎么样使用<tt class="literal">@javax.persistence.OrderBy</tt>
		  注解来对有序列表进行映射：
		  该注解接受的参数格式：用逗号隔开的(目标实体)属性名及排序指令,
		  如<tt class="code">firstname asc, age desc</tt>,如果该参数为空,则默认以id对该集合进行排序.
           如果某个集合在数据库中对应一个关联表(association table)的话,你不能在这个集合属性上面使用@OrderBy注解.
		  对于这种情况的处理方法,请参考<a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-hibspec">Hibernate Annotation Extensions</a>.
		  EJB3 允许你利用目标实体的一个属性作为Map的key,
		  这个属性可以用<tt class="literal">@MapKey(name="myProperty")</tt>来声明.
		  如果使用<tt class="literal">@MapKey</tt>注解的时候不提供属性名,
		  系统默认使用目标实体的主键.
		  map的key使用和属性相同的列：不需要为map key定义专用的列，因为map key实际上就表达了一个目标属性。
		  注意一旦加载,key不再和属性保持同步,
		  也就是说,如果你改变了该属性的值,在你的Java模型中的key不会自动更新
		  (请参考<a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-hibspec">Hibernate Annotation Extensions</a>).
		  很多人被<tt class="literal">&lt;map&gt;</tt>和<tt class="literal">@MapKey</tt>弄糊涂了。
		  其他它们有两点区别.<tt class="literal">@MapKey</tt>目前还有一些限制,详情请查看论坛或者
		  我们的JIRA缺陷系统。


		  注意一旦加载,key不再和属性保持同步,
		  也就是说,如果你改变了该属性的值,在你的Java模型中的key不会自动更新.
		  (Hibernate 3中Map支持的方式在当前的发布版中还未得到支持).</p><p>Hibernate将集合分以下几类.</p><p></p><div class="table"><a name="d0e1397"></a><p class="title"><b>表&nbsp;2.1.&nbsp;集合语义</b></p><table summary="集合语义" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>语义</th><th>Java实现类</th><th> 注解</th></tr></thead><tbody><tr><td>Bag 语义</td><td>java.util.List, java.util.Collection</td><td>@org.hibernate.annotations.CollectionOfElements 或
                  @OneToMany 或 @ManyToMany</td></tr><tr><td>List 语义</td><td>java.util.List</td><td>(@org.hibernate.annotations.CollectionOfElements 或
                  @OneToMany 或 @ManyToMany) 
				  以及
                  @org.hibernate.annotations.IndexColumn</td></tr><tr><td>Set 语义</td><td>java.util.Set</td><td>@org.hibernate.annotations.CollectionOfElements 或
                  @OneToMany 或 @ManyToMany</td></tr><tr><td>Map 语义</td><td>java.util.Map</td><td>(@org.hibernate.annotations.CollectionOfElements 或
                  @OneToMany 或 @ManyToMany)
				  以及
				  (空 
				  或
                  @org.hibernate.annotations.MapKey/MapKeyManyToMany(支持真正的map), 
				  或
                  @javax.persistence.MapKey</td></tr></tbody></table></div><i><span class="remark">
		  从上面可以明确地看到,没有@org.hibernate.annotations.IndexColumn 
		  注解的java.util.List集合将被看作bag类.
		  </span></i><p>EJB3规范不支持原始类型,核心类型,嵌入式对象的集合.但是Hibernate对此提供了支持
		  (详情参考 <a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#entity-hibspec">Hibernate Annotation Extensions</a>).</p><pre class="programlisting">@Entity public class City {
    @OneToMany(mappedBy="city")
    <span class="bold"><b>@OrderBy("streetName")</b></span>
    public List&lt;Street&gt; getStreets() {
        return streets;
    }
...
}

@Entity public class Street {
    <span class="bold"><b>public String getStreetName()</b></span> {
        return streetName;
    }

    @ManyToOne
    public City getCity() {
        return city;
    }
    ...
}


@Entity
public class Software {
    @OneToMany(mappedBy="software")
    <span class="bold"><b>@MapKey(name="codeName")</b></span>
    public Map&lt;String, Version&gt; getVersions() {
        return versions;
    }
...
}

@Entity
@Table(name="tbl_version")
public class Version {
    <span class="bold"><b>public String getCodeName()</b></span> {...}

    @ManyToOne
    public Software getSoftware() { ... }
...
}</pre><p>上面这个例子中,<tt class="literal">City</tt>
		  中包括了以<tt class="literal">streetName</tt>排序的<tt class="literal">Street</tt>的集合.
		  而<tt class="literal">Software</tt>中包括了以<tt class="literal">codeName</tt>作为
		  key和以<tt class="literal">Version</tt>作为值的Map.</p><p>除非集合为generic类型,否则你需要指定<tt class="literal">targetEntity</tt>.
		  这个注解属性接受的参数为目标实体的class.</p></div><div class="sect4" lang="zh_cn"><div class="titlepage"><div><div><h5 class="title"><a name="entity-mapping-association-collection-onetomany"></a>2.2.5.3.2.&nbsp;一对多(One-to-many)</h5></div></div><div></div></div><p>在属性级使用 <tt class="literal">@OneToMany</tt>注解可定义一对多关联.一对多关联可以是双向关联.</p><div class="sect5" lang="zh_cn"><div class="titlepage"><div><div><h6 class="title"><a name="d0e1494"></a>2.2.5.3.2.1.&nbsp;双向(Bidirectional)</h6></div></div><div></div></div><p>在EJB3规范中多对一这端几乎总是双向关联中的主体(owner)端,
			而一对多这端的关联注解为<tt class="literal">@OneToMany( mappedBy=...
            )</tt></p><pre class="programlisting">@Entity
public class Troop {
    @OneToMany(mappedBy="troop")
    public Set&lt;Soldier&gt; getSoldiers() {
    ...
}

@Entity
public class Soldier {
    @ManyToOne
    @JoinColumn(name="troop_fk")
    public Troop getTroop() {
    ...
}              </pre><p><tt class="classname">Troop</tt> 通过<tt class="literal">troop</tt> 
			属性和<tt class="literal">Soldier</tt>建立了一对多的双向关联.
			在<tt class="literal">mappedBy</tt>端不必也不能再定义任何物理映射</p><p>对于一对多的双向映射,如果要一对多这一端维护关联关系,
			你需要删除<tt class="literal">mappedBy</tt>元素并将多对一这端的
			 <tt class="literal">@JoinColumn</tt>的insertable和updatable设置为false.
			很明显,这种方案不会得到什么明显的优化,而且还会增加一些附加的UPDATE语句.</p><pre class="programlisting">@Entity
public class Troop {
    @OneToMany
    @JoinColumn(name="troop_fk") //we need to duplicate the physical information
    public Set&lt;Soldier&gt; getSoldiers() {
    ...
}

@Entity
public class Soldier {
    @ManyToOne
    @JoinColumn(name="troop_fk", insertable=false, updatable=false)
    public Troop getTroop() {
    ...
}</pre></div><div class="sect5" lang="zh_cn"><div class="titlepage"><div><div><h6 class="title"><a name="d0e1526"></a>2.2.5.3.2.2.&nbsp;单向(Unidirectional)</h6></div></div><div></div></div><p>通过在被拥有的实体端(owned entity)增加一个外键列来实现一对多单向关联是很少见的,也是不推荐的.
			我们强烈建议通过一个联接表(join table)来实现这种关联(下一节会对此进行解释).
			可以通过<tt class="literal">@JoinColumn</tt>注解来描述这种单向关联关系.</p><pre class="programlisting">@Entity
public class Customer implements Serializable {
    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @JoinColumn(name="CUST_ID")
    public Set&lt;Ticket&gt; getTickets() {
    ...
}

@Entity
public class Ticket implements Serializable {
    ... //no bidir
}
               </pre><p><tt class="literal">Customer</tt> 通过
			<tt class="literal">CUST_ID</tt>列和<tt class="literal">Ticket</tt> 建立了单向关联关系.</p></div><div class="sect5" lang="zh_cn"><div class="titlepage"><div><div><h6 class="title"><a name="d0e1546"></a>2.2.5.3.2.3.&nbsp;通过关联表处理单向关联</h6></div></div><div></div></div><p>通过联接表处理单向一对多关联是首选方式.这种关联通过<tt class="literal">@JoinTable</tt>注解来进行描述.</p><pre class="programlisting">@Entity
public class Trainer {
    @OneToMany
    @JoinTable(
            name="TrainedMonkeys",
            joinColumns = @JoinColumn( name="trainer_id"),
            inverseJoinColumns = @JoinColumn( name="monkey_id")
    )
    public Set&lt;Monkey&gt; getTrainedMonkeys() {
    ...
}

@Entity
public class Monkey {
    ... //no bidir
}
               </pre><p>上面这个例子中,<tt class="literal">Trainer</tt>通过
			<tt class="classname">TrainedMonkeys</tt>表和
			<tt class="classname">Monkey</tt> 建立了单向关联. 
			其中外键<tt class="literal">trainer_id</tt>关联到<tt class="literal">Trainer</tt>
			(<tt class="literal">joinColumns</tt>),
			而外键<tt class="literal">monkey_id</tt>关联到 <tt class="literal">Monkey</tt>
			(<tt class="literal">inversejoinColumns</tt>).</p></div><div class="sect5" lang="zh_cn"><div class="titlepage"><div><div><h6 class="title"><a name="d0e1585"></a>2.2.5.3.2.4.&nbsp;默认处理机制</h6></div></div><div></div></div><p>通过联接表来建立单向一对多关联不需要描述任何物理映射.
            表名由以下三个部分组成:主表(owner table)表名+下划线+从表(the other side table)表名.
            指向主表的外键名：主表表名+下划线+主表主键列名
            指向从表的外键名：主表所对应实体的属性名+下划线+从表主键列名
            指向从表的外键定义为唯一约束,用来表示一对多的关联关系.</p><pre class="programlisting">@Entity
public class Trainer {
    @OneToMany
    public Set&lt;Tiger&gt; getTrainedTigers() {
    ...
}

@Entity
public class Tiger {
    ... //no bidir
}
               </pre><p>上面这个例子中,<tt class="classname">Trainer</tt>和<tt class="classname">Tiger</tt>
			通过联接表 <tt class="literal">Trainer_Tiger</tt>建立单向关联关系,
			其中外键<tt class="literal">trainer_id</tt>关联到<tt class="literal">Trainer</tt>
			(主表表名, <span><b class="keycap">_</b></span>(下划线), trainer id),
			而外键<tt class="literal">trainedTigers_id</tt>关联到<tt class="literal">Tiger</tt>
			(属性名称,  <span><b class="keycap">_</b></span>(下划线), Tiger表的主键列名).</p></div></div><div class="sect4" lang="zh_cn"><div class="titlepage"><div><div><h5 class="title"><a name="d0e1621"></a>2.2.5.3.3.&nbsp;多对多(Many-to-many)</h5></div></div><div></div></div><div class="sect5" lang="zh_cn"><div class="titlepage"><div><div><h6 class="title"><a name="d0e1624"></a>2.2.5.3.3.1.&nbsp;定义</h6></div></div><div></div></div><p>你可以通过<tt class="literal">@ManyToMany</tt>注解可定义的多对多关联.
			同时,你也需要通过注解<tt class="literal">@JoinTable</tt>描述关联表和关联条件.
			如果是双向关联,其中一段必须定义为owner,另一端必须定义为inverse(在对关联表进行更新操作时这一端将被忽略):</p><pre class="programlisting">@Entity
public class Employer implements Serializable {
    @ManyToMany(
        targetEntity=org.hibernate.test.metadata.manytomany.Employee.class,
        cascade={CascadeType.PERSIST, CascadeType.MERGE}
    )
    @JoinTable(
        name="EMPLOYER_EMPLOYEE",
        joinColumns=@JoinColumn(name="EMPER_ID"),
        inverseJoinColumns=@JoinColumn(name="EMPEE_ID")
    )
    public Collection getEmployees() {
        return employees;
    }
    ...
}
               </pre><pre class="programlisting">@Entity
public class Employee implements Serializable {
    @ManyToMany(
        cascade = {CascadeType.PERSIST, CascadeType.MERGE},
        mappedBy = "employees",
        targetEntity = Employer.class
    )
    public Collection getEmployers() {
        return employers;
    }
}
               </pre><p>至此,我们已经展示了很多跟关联有关的声明定义以及属性细节.
			下面我们将深入介绍<tt class="literal">@JoinTable</tt>注解,该注解定义了联接表的表名,
			联接列数组(注解中定义数组的格式为{ A, B, C }),
			以及inverse联接列数组.
			后者是关联表中关联到<tt class="classname">Employee</tt>主键的列(the "other side").</p><p>正如前面所示,被关联端不必也不能描述物理映射: 
			只需要一个简单的<tt class="literal">mappedBy</tt>参数,该参数包含了主体端的属性名,这样就绑定双方的关系.</p></div><div class="sect5" lang="zh_cn"><div class="titlepage"><div><div><h6 class="title"><a name="d0e1652"></a>2.2.5.3.3.2.&nbsp;默认值</h6></div></div><div></div></div><p>和其他许多注解一样,在多对多关联中很多值是自动生成.
			当双向多对多关联中没有定义任何物理映射时,Hibernate根据以下规则生成相应的值.
			关联表名:主表表名+<span><b class="keycap">_</b></span>下划线+从表表名,
			关联到主表的外键名:主表名+<span><b class="keycap">_</b></span>下划线+主表中的主键列名.
			关联到从表的外键名:主表中用于关联的属性名+<span><b class="keycap">_</b></span>下划线+从表的主键列名.
			以上规则对于双向一对多关联同样有效.</p><pre class="programlisting">@Entity
public class Store {
    @ManyToMany(cascade = CascadeType.PERSIST)
    public Set&lt;City&gt; getImplantedIn() {
        ...
    }
}

@Entity
public class City {
    ... //no bidirectional relationship
}
               </pre><p>上面这个例子中,<tt class="literal">Store_Table</tt>作为联接表. 
			<tt class="literal">Store_id</tt>列是联接到<tt class="literal">Store</tt>表的外键.
			而<tt class="literal">implantedIn_id</tt>列则联接到<tt class="literal">City</tt>表.</p><p>当双向多对多关联中没有定义任何物理映射时, Hibernate根据以下规则生成相应的值
            关联表名: :主表表名+<span><b class="keycap">_</b></span>下划线+从表表名,
            关联到主表的外键名:从表用于关联的属性名+<span><b class="keycap">_</b></span>下划线+主表中的主键列名.
            关联到从表的外键名:主表用于关联的属性名+<span><b class="keycap">_</b></span>下划线+从表的主键列名.
            以上规则对于双向一对多关联同样有效.</p><pre class="programlisting">@Entity
public class Store {
    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    public Set&lt;Customer&gt; getCustomers() {
        ...
    }
}

@Entity
public class Customer {
    @ManyToMany(mappedBy="customers")
    public Set&lt;Store&gt; getStores() {
        ...
    }
}
               </pre><p>在上面这个例子中,<tt class="literal">Store_Customer</tt>作为联接表. 
			<tt class="literal">stores_id</tt>列是联接到<tt class="literal">Store</tt>表的外键,
			而<tt class="literal">customers_id</tt>列联接到<tt class="literal">City</tt>表.</p></div></div></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1715"></a>2.2.5.4.&nbsp;用cascading实现传播性持久化(Transitive persistence)</h4></div></div><div></div></div><p>也许你已经注意到了<tt class="literal">cascade</tt>属性接受的值为<tt class="classname">CascadeType</tt>数组.
		在EJB3中的cascade的概念和Hibernate中的传播性持久化以及cascade操作非常类似,
		但是在语义上有细微的区别,支持的cascade类型也有点区别:</p><div class="itemizedlist"><ul type="disc"><li>
             CascadeType.PERSIST: 如果一个实体是受管状态, 或者当persist()函数被调用时, 触发级联创建(create)操作
          </li><li>
             CascadeType.MERGE: 如果一个实体是受管状态, 或者当merge()函数被调用时, 触发级联合并(merge)操作
          </li><li>
             CascadeType.REMOVE: 当delete()函数被调用时, 触发级联删除(remove)操作
          </li><li>
             CascadeType.REFRESH: 当refresh()函数被调用时, 触发级联更新(refresh)操作
          </li><li>
             CascadeType.ALL: 以上全部
          </li></ul></div><p>关于cascading, create/merge的语义请参考EJB3规范的6.3章节.</p></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1739"></a>2.2.5.5.&nbsp;关联关系获取</h4></div></div><div></div></div><p>通过Hibernate你可以获得直接或者延迟获取关联实体的功能.
		<tt class="literal">fetch</tt>参数可以设置为<tt class="literal">FetchType.LAZY</tt> 
		或者 <tt class="literal">FetchType.EAGER</tt>.
		<tt class="literal">EAGER</tt>通过<tt class="literal">outer join select</tt>直接获取关联的对象,
		而<tt class="literal">LAZY</tt>(默认值)在第一次访问关联对象的时候才会触发相应的select操作.
		EJBQL提供了<tt class="literal">fetch</tt>关键字,该关键字可以在进行特殊查询的时候覆盖默认值.
		这对于提高性能来说非常有效,应该根据实际的用例来判断是否选择fetch关键字.</p></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1765"></a>2.2.6.&nbsp;映射复合主键与外键</h3></div></div><div></div></div><p>组合主键使用一个可嵌入的类作为主键表示,因此你需要使用<tt class="literal">@Id</tt>
	  和<tt class="literal">@Embeddable</tt>两个注解.
	  还有一种方式是使用<tt class="literal">@EmbeddedId</tt>注解.注意所依赖的类必须实现
	  serializable以及实现<tt class="methodname">equals()</tt>/<tt class="methodname">hashCode()</tt>方法.
	  你也可以如<a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#mapping-identifier">Mapping identifier properties</a>一章中描述的办法使用<tt class="literal">@IdClass</tt>注解.</p><pre class="programlisting">@Entity
public class RegionalArticle implements Serializable {

    @Id
    public RegionalArticlePk getPk() { ... }
}

@Embeddable
public class RegionalArticlePk implements Serializable { ... }
         </pre><p>或者</p><pre class="programlisting">@Entity
public class RegionalArticle implements Serializable {

    @EmbeddedId
    public RegionalArticlePk getPk() { ... }
}

public class RegionalArticlePk implements Serializable { ... }
         </pre><p><tt class="literal">@Embeddable</tt> 注解默认继承了其所属实体的访问类型,
	  除非显式使用了Hibernate的<tt class="literal">@AccessType</tt>注解(这个注解不是EJB3标准的一部分).
	  而<tt class="literal">@JoinColumns</tt>,即<tt class="literal">@JoinColumn</tt>数组,
	  定义了关联的组合外键(如果不使用缺省值的话).
	  显式指明<tt class="literal">referencedColumnNames</tt>是一个好的实践方式,
	  否则,Hibernate认为你使用的列顺序和主键声明的顺序一致.</p><pre class="programlisting">@Entity
public class Parent implements Serializable {
    @Id
    public ParentPk id;
    public int age;

    @OneToMany(cascade=CascadeType.ALL)
    @JoinColumns ({
        @JoinColumn(name="parentCivility", referencedColumnName = "isMale"),
        @JoinColumn(name="parentLastName", referencedColumnName = "lastName"),
        @JoinColumn(name="parentFirstName", referencedColumnName = "firstName")
    })
    public Set&lt;Child&gt; children; //unidirectional
    ...
}
         </pre><pre class="programlisting">@Entity
public class Child implements Serializable {
    @Id @GeneratedValue
    public Integer id;

    @ManyToOne
    @JoinColumns ({
        @JoinColumn(name="parentCivility", referencedColumnName = "isMale"),
        @JoinColumn(name="parentLastName", referencedColumnName = "lastName"),
        @JoinColumn(name="parentFirstName", referencedColumnName = "firstName")
    })
    public Parent parent; //unidirectional
}
         </pre><pre class="programlisting">@Embeddable
public class ParentPk implements Serializable {
    String firstName;
    String lastName;
    ...
}
         </pre><p>注意上面的 <tt class="literal">referencedColumnName</tt>显式使用方式.</p></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1823"></a>2.2.7.&nbsp;映射二级表(secondary tables)</h3></div></div><div></div></div><p>使用类一级的 <tt class="literal">@SecondaryTable </tt> 或 
	   <tt class="literal">@SecondaryTables </tt>注解可以实现单个实体到多个表的映射.
	  使用 <tt class="literal">@Column  </tt>或者  <tt class="literal">@JoinColumn  </tt>
	  注解中的 <tt class="literal">table </tt>参数可指定某个列所属的特定表.</p><pre class="programlisting">@Entity
@Table(name="MainCat")
<span class="bold"><b>@SecondaryTables({
    @SecondaryTable(name="Cat1", pkJoinColumns={
        @PrimaryKeyJoinColumn(name="cat_id", referencedColumnName="id")
    ),
    @SecondaryTable(name="Cat2", uniqueConstraints={@UniqueConstraint(columnNames={"storyPart2"})})
})</b></span>
public class Cat implements Serializable {

    private Integer id;
    private String name;
    private String storyPart1;
    private String storyPart2;

    @Id @GeneratedValue
    public Integer getId() {
        return id;
    }

    public String getName() {
        return name;
    }
    
    <span class="bold"><b>@Column(table="Cat1")</b></span>
    public String getStoryPart1() {
        return storyPart1;
    }

    <span class="bold"><b>@Column(table="Cat2")</b></span>
    public String getStoryPart2() {
        return storyPart2;
    }
</pre><p>在上面这个例子中,<tt class="literal">name</tt>保存在<tt class="literal">MainCat</tt>表中,
	  <tt class="literal">storyPart1</tt>保存在<tt class="literal">Cat1</tt>表中,
	  <tt class="literal">storyPart2</tt>保存在<tt class="literal">Cat2</tt>表中.
	  <tt class="literal">Cat1</tt>表通过外键<tt class="literal">cat_id</tt>和<tt class="literal">MainCat</tt>表关联,
	  <tt class="literal">Cat2</tt>表通过<tt class="literal">id</tt>列和<tt class="literal">MainCat</tt>表关联
	  (和<tt class="literal">MainCat</tt>的<tt class="literal">id</tt>列同名).
	  对<tt class="literal">storyPart2</tt>列还定义了唯一约束.</p><p>在JBoss EJB 3指南和Hibernate Annotations单元测试代码中还有更多的例子.</p></div></div><div class="sect1" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="entity-mapping-query"></a>2.3.&nbsp;映射查询</h2></div></div><div></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1906"></a>2.3.1.&nbsp;映射EJBQL/HQL查询</h3></div></div><div></div></div><p>使用注解还可以映射EJBQL/HQL查询.
	  <tt class="literal">@NamedQuery</tt> 和<tt class="literal">@NamedQueries</tt>是可使用在类和包上的注解.
	  但是它们的定义在session factory/entity manager factory范围中是都可见的.
	  命名式查询通过它的名字和实际的查询字符串来定义.</p><pre class="programlisting">javax.persistence.NamedQueries(
    @javax.persistence.NamedQuery(name="plane.getAll", query="select p from Plane p")
)
package org.hibernate.test.annotations.query;

...

@Entity
@NamedQuery(name="night.moreRecentThan", query="select n from Night n where n.date &gt;= :date")
public class Night {
    ...
}

public class MyDao {
    doStuff() {
        Query q = s.getNamedQuery("night.moreRecentThan");
        q.setDate( "date", aMonthAgo );
        List results = q.list();
        ...
    }
    ...
}
        </pre><p>还可以通过定义 <tt class="literal">QueryHint</tt> 数组的<tt class="literal">hints</tt>
	  属性为查询提供一些hint信息.</p><p>下面是目前可以使用的一些Hibernate hint：</p><p></p><div class="table"><a name="d0e1930"></a><p class="title"><b>表&nbsp;2.2.&nbsp;Query hints</b></p><table summary="Query hints" border="1"><colgroup><col><col></colgroup><thead><tr><th>hint</th><th>description</th></tr></thead><tbody><tr><td>org.hibernate.cacheable</td><td>查询是否与二级缓存交互(默认值为false)
	      </td></tr><tr><td>org.hibernate.cacheRegion</td><td>设置缓存区名称 (默认为otherwise)</td></tr><tr><td>org.hibernate.timeout</td><td>查询超时设定</td></tr><tr><td>org.hibernate.fetchSize</td><td>所获取的结果集(resultset)大小</td></tr><tr><td>org.hibernate.flushMode</td><td>本次查询所用的刷新模式</td></tr><tr><td>org.hibernate.cacheMode</td><td>本次查询所用的缓存模式</td></tr><tr><td>org.hibernate.readOnly</td><td>是否将本次查询所加载的实体设为只读(默认为false)
	      </td></tr><tr><td>org.hibernate.comment</td><td>将查询注释添加入所生成的SQL</td></tr></tbody></table></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="entity-mapping-query-native"></a>2.3.2.&nbsp;映射本地化查询</h3></div></div><div></div></div><p>你还可以映射本地化查询(也就是普通SQL查询).
	  不过这需要你使用<tt class="literal">@SqlResultSetMapping</tt>注解来描述SQL的resultset的结构
	  (如果你打算定义多个结果集映射，可是使用<tt class="literal">@SqlResultSetMappings</tt>).
	  <tt class="literal">@SqlResultSetMapping</tt>和<tt class="literal">@NamedQuery</tt>,
	  <tt class="literal">@SqlResultSetMapping</tt>一样,可以定义在类和包一级.
	  但是<tt class="literal">@SqlResultSetMapping</tt>的作用域为应用级.
	  下面我们会看到,<tt class="literal">@NamedNativeQuery</tt> 注解中
	  <tt class="literal">resultSetMapping</tt>参数值为<tt class="literal">@SqlResultSetMapping</tt>的名字.
	  结果集映射定义了通过本地化查询返回值和实体的映射.
	  该实体中的每一个字段都绑定到SQL结果集中的某个列上.
	  该实体的所有字段包括子类的所有字段以及
	  关联实体的外键列都必须在SQL查询中有对应的定义.
	  如果实体中的属性和SQL查询中的列名相同,这种情况下可以不进行定义字段映射.</p><pre class="programlisting">@NamedNativeQuery(name="night&amp;area", query="select night.id nid, night.night_duration, "
    + " night.night_date, area.id aid, night.area_id, area.name "
    + "from Night night, Area area where night.area_id = area.id", <span class="bold"><b>resultSetMapping="joinMapping"</b></span>)
@SqlResultSetMapping(name="joinMapping", entities={
    @EntityResult(entityClass=org.hibernate.test.annotations.query.Night.class, fields = {
        @FieldResult(name="id", column="nid"),
        @FieldResult(name="duration", column="night_duration"),
        @FieldResult(name="date", column="night_date"),
        @FieldResult(name="area", column="area_id"),
        discriminatorColumn="disc"
    }),
    @EntityResult(entityClass=org.hibernate.test.annotations.query.Area.class, fields = {
        @FieldResult(name="id", column="aid"),
        @FieldResult(name="name", column="name")
    })
    }
)</pre><p>在上面这个例子中,名为<tt class="literal">night&amp;area</tt>的查询
	  和<tt class="literal">joinMapping</tt>结果集映射对应.
	  该映射返回两个实体,分别为<tt class="literal">Night</tt> 
	  和<tt class="literal">Area</tt>,其中每个属性都和一个列关联,
	  列名通过查询获取.下面我们看一个隐式声明属性和列映射关系的例子.</p><pre class="programlisting">@Entity
<span class="bold"><b>@SqlResultSetMapping(name="implicit", entities=@EntityResult(entityClass=org.hibernate.test.annotations.query.SpaceShip.class))
@NamedNativeQuery(name="implicitSample", query="select * from SpaceShip", resultSetMapping="implicit")</b></span>
public class SpaceShip {
    private String name;
    private String model;
    private double speed;

    @Id
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Column(name="model_txt")
    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }
}</pre><p>在这个例子中,我们只需要定义结果集映射中的实体成员.
	  属性和列名之间的映射借助实体中包含映射信息来完成.
	  在这个例子中,<tt class="literal">model</tt>属性绑定到<tt class="literal">model_txt</tt>列.
	  如果和相关实体的关联设计到组合主键,
	  那么应该使用<tt class="literal">@FieldResult</tt>注解来定义每个外键列.
	  <tt class="literal">@FieldResult</tt>的名字由以下几部分组成：
	  定义这种关系的属性名字+"."＋主键名或主键列或主键属性.</p><pre class="programlisting">@Entity
@SqlResultSetMapping(name="compositekey",
        entities=@EntityResult(entityClass=org.hibernate.test.annotations.query.SpaceShip.class,
            fields = {
                    @FieldResult(name="name", column = "name"),
                    @FieldResult(name="model", column = "model"),
                    @FieldResult(name="speed", column = "speed"),
<span class="bold"><b>                    @FieldResult(name="captain.firstname", column = "firstn"),
                    @FieldResult(name="captain.lastname", column = "lastn"),</b></span>
                    @FieldResult(name="dimensions.length", column = "length"),
                    @FieldResult(name="dimensions.width", column = "width")
                    }),
        columns = { @ColumnResult(name = "surface"),
                    @ColumnResult(name = "volume") } )

@NamedNativeQuery(name="compositekey",
    query="select name, model, speed, lname as lastn, fname as firstn, length, width, length * width as surface from SpaceShip", 
    resultSetMapping="compositekey")
} )
public class SpaceShip {
    private String name;
    private String model;
    private double speed;
    private Captain captain;
    private Dimensions dimensions;

    @Id
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @ManyToOne(fetch= FetchType.LAZY)
    @JoinColumns( {
            @JoinColumn(name="fname", referencedColumnName = "firstname"),
            @JoinColumn(name="lname", referencedColumnName = "lastname")
            } )
    public Captain getCaptain() {
        return captain;
    }

    public void setCaptain(Captain captain) {
        this.captain = captain;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }

    public Dimensions getDimensions() {
        return dimensions;
    }

    public void setDimensions(Dimensions dimensions) {
        this.dimensions = dimensions;
    }
}

@Entity
@IdClass(Identity.class)
public class Captain implements Serializable {
    private String firstname;
    private String lastname;

    @Id
    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    @Id
    public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }
}
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>观察dimension属性你会发现Hibernate支持用"."符号来表示嵌入式对象.
		EJB3实现不必支持这个特征,但是我们做到了:-)</p></div><p>如果查询返回的是单个实体,或者你打算使用系统默认的映射,
	  这种情况下可以不使用<tt class="literal">resultSetMapping</tt>
	  而是使用<tt class="literal">resultClass</tt>属性:</p><pre class="programlisting"><span class="bold"><b>@NamedNativeQuery(name="implicitSample", query="select * from SpaceShip", 
    resultClass=SpaceShip.class)</b></span>
public class SpaceShip {</pre><p>某些本地查询返回的是scalar值,例如报表查询.
	  你可以通过<tt class="literal">@ColumnResult</tt>将其映射到
	  <tt class="literal">@SqlResultsetMapping</tt>上.
	  甚至还可以在同一个本地查询的结果中混合实体和scalar类型(不过这种情况比较少见).</p><pre class="programlisting"><span class="bold"><b>@SqlResultSetMapping(name="scalar", columns=@ColumnResult(name="dimension"))
@NamedNativeQuery(name="scalar", query="select length*width as dimension from SpaceShip", resultSetMapping="scalar")</b></span></pre><p>本地查询中还有另外一个hint属性：
	  <tt class="literal">org.hibernate.callable</tt>.
	  这个属性的布尔变量值表明这个查询是否是一个存储过程.</p></div></div><div class="sect1" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="entity-hibspec"></a>2.4.&nbsp;Hibernate独有的注解扩展</h2></div></div><div></div></div><p>Hibernate 3.1 提供了多种附加的注解,这些注解可以与EJB3的实体混合/匹配使用.
    他们被设计成EJB3注解的自然扩展.</p><p>为了强化EJB3的能力,Hibernate提供了与其自身特性相吻合的特殊注解.
    <tt class="classname">org.hibernate.annotations</tt>包已包含了所有的这些注解扩展.</p><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="entity-hibspec-entity"></a>2.4.1.&nbsp;实体</h3></div></div><div></div></div><p>你可以在EJB3规范所能提供的能力之外,就Hibernate对实体所做的一些操作进行优化.</p><p><tt class="classname">@org.hibernate.annotations.Entity</tt>
      追加了可能需要的额外的元数据,
      而这些元数据超出了标准<tt class="literal">@Entity</tt> 中所定义的元数据. 
		</p><div class="itemizedlist"><ul type="disc"><li>
             mutable: 此实体是否为可变的
          </li><li>
             dynamicInsert: 用动态SQL新增
          </li><li>
             dynamicUpdate: 用动态SQL更新
          </li><li>
             selectBeforeUpdate: 指明Hibernate从不运行SQL UPDATE除非能确定对象的确已被修改
          </li><li>
             polymorphism: (指出)实体多态是PolymorphismType.IMPLICIT(默认)还是PolymorphismType.EXPLICIT 
		  </li><li>
             persister:允许对默认持久实现(persister implementation)的覆盖
		  </li><li>
             optimisticLock: 乐观锁策略(OptimisticLockType.VERSION, OptimisticLockType.NONE, OptimisticLockType.DIRTY或OptimisticLockType.ALL)
          </li></ul></div><p>
	  </p><p>
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>
				@javax.persistence.Entity仍是必选的(mandatory),
				@org.hibernate.annotations.Entity不是取代品.
			</p></div><p>
	  </p><p>以下是一些附加的Hibernate注解扩展：</p><p><tt class="literal">@org.hibernate.annotations.BatchSize</tt> 
		允许你定义批量获取该实体的实例数量(如：<tt class="literal">@BatchSize(size=4)</tt>).
      当加载一特定的实体时,Hibernate将加载在持久上下文中未经初始化的同类型实体,直至批量数量(上限).</p><p><tt class="literal">@org.hibernate.annotations.Proxy</tt>
      定义了实体的延迟属性.Lazy(默认为true)定义了类是否为延迟(加载).
      proxyClassName是用来生成代理的接口(默认为该类本身).</p><p><tt class="literal">@org.hibernate.annotations.Where</tt>
		定义了当获取类实例时所用的SQL WHERE子句(该SQL WHERE子句为可选).</p><p><tt class="literal">@org.hibernate.annotations.Check</tt>
      定义了在DDL语句中定义的合法性检查约束(该约束为可选).</p><p><tt class="literal">@OnDelete(action=OnDeleteAction.CASCADE)</tt>
      定义于被连接的子类(joined subclass)：在删除时使用SQL级连删除,而非通常的Hibernate删除机制.</p><p><tt class="literal">@Table(name="tableName", indexes = {
      @Index(name="index1", columnNames={"column1", "column2"} ) } )</tt>
	  在<tt class="literal">tableName</tt>表的列上创建定义好的索引.
	  该注解可以被应用于关键表或者是其他次要的表.
      <tt class="literal">@Tables</tt> 注解允许你在不同的表上应用索引.
      此注解预期在使用
      <tt class="literal">@javax.persistence.Table</tt>或
      <tt class="literal">@javax.persistence.SecondaryTable</tt>的地方中出现.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>
		<tt class="literal">@org.hibernate.annotations.Table</tt> 是对
        <tt class="literal">@javax.persistence.Table</tt>的补充而不是它的替代品.
		特别是当你打算改变表名的默认值的时候，你必须使用<tt class="literal">@javax.persistence.Table</tt>,
		而不是<tt class="literal">@org.hibernate.annotations.Table</tt>.</p></div><pre class="programlisting">@Entity
@BatchSize(size=5)
@org.hibernate.annotations.Entity(
        selectBeforeUpdate = true,
        dynamicInsert = true, dynamicUpdate = true,
        optimisticLock = OptimisticLockType.ALL,
        polymorphism = PolymorphismType.EXPLICIT)
@Where(clause="1=1")
@org.hibernate.annotations.Table(name="Forest", indexes = { @Index(name="idx", columnNames = { "name", "length" } ) } )
public class Forest { ... }</pre><pre class="programlisting">@Entity
@Inheritance(
    strategy=InheritanceType.JOINED
)
public class Vegetable { ... }

@Entity
@OnDelete(action=OnDeleteAction.CASCADE)
public class Carrot extends Vegetable { ... }</pre></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2195"></a>2.4.2.&nbsp;标识符</h3></div></div><div></div></div><p><tt class="literal"><tt class="literal">@org.hibernate.annotations.GenericGenerator</tt>
      允许你定义一个Hibernate特定的id生成器.</tt></p><pre class="programlisting">@Id @GeneratedValue(generator="system-uuid")
@GenericGenerator(name="system-uuid", strategy = "uuid")
public String getId() {

@Id @GeneratedValue(generator="hibseq")
@GenericGenerator(name="hibseq", strategy = "seqhilo",
    parameters = {
        @Parameter(name="max_lo", value = "5"),
        @Parameter(name="sequence", value="heybabyhey")
    }
)
public Integer getId() {</pre><p><tt class="literal">strategy</tt>可以是Hibernate3生成器策略的简称,
	或者是一个<tt class="classname">IdentifierGenerator</tt>实现的(带包路径的)全限定类名.
	你可以通过<tt class="literal">parameters</tt>属性增加一些参数.</p></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="entity-hibspec-property"></a>2.4.3.&nbsp;属性</h3></div></div><div></div></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2219"></a>2.4.3.1.&nbsp;访问类型</h4></div></div><div></div></div><p>访问类型是根据<tt class="literal">@Id</tt>或<tt class="literal">@EmbeddedId</tt>
	在实体继承层次中所处的位置推演而得的.子实体(Sub-entities),
	内嵌对象和被映射的父类均继承了根实体(root entity)的访问类型.</p><p>在Hibernate中,你可以把访问类型覆盖成：</p><div class="itemizedlist"><ul type="disc"><li><p>使用定制的访问类型策略</p></li><li><p>优化类级或属性级的访问类型</p></li></ul></div><p>为支持这种行为,Hibernate引入了@AccessType注解.你可以对以下元素定义访问类型：</p><div class="itemizedlist"><ul type="disc"><li><p>实体</p></li><li><p>父类</p></li><li><p>可内嵌的对象</p></li><li><p>属性</p></li></ul></div><p>被注解元素的访问类型会被覆盖,若覆盖是在类一级上,则所有的属性继承访问类型.
		对于根实体,其访问类型会被认为是整个继承层次中的缺省设置(可在类或属性一级覆盖).</p><p>若访问类型被标以"property",则Hibernate会扫描getter方法的注解,若访问类型被标以"field",
		则扫描字段的注解.否则,扫描标为@Id或@embeddedId的元素.</p><p>你可以覆盖某个属性(property)的访问类型,但是受注解的元素将不受影响：
			例如一个具有field访问类型的实体,(我们)可以将某个字段标注为 @AccessType("property"),
			则该字段的访问类型随之将成为property,但是其他字段上依然需要携带注解.</p><p>若父类或可内嵌的对象没有被注解,则使用根实体的访问类型(即使已经在非直系父类或可内嵌对象上定义了访问类型).
			此时俄罗斯套娃(Russian doll)原理就不再适用.(译注：俄罗斯套娃(матрёшка或 матрешка)是俄罗斯特产木制玩具,
			一般由多个一样图案的空心木娃娃一个套一个组成,最多可达十多个,通常为圆柱形,底部平坦可以直立.)</p><pre class="programlisting">@Entity
public class Person implements Serializable {
    @Id  @GeneratedValue //access type field
    Integer id;

    @Embedded
    @AttributeOverrides({
    @AttributeOverride(name = "iso2", column = @Column(name = "bornIso2")),
    @AttributeOverride(name = "name", column = @Column(name = "bornCountryName"))
            })
    Country bornIn;
}

@Embeddable
<span class="bold"><b>@AccessType("property")</b></span> //override access type for all properties in Country
public class Country implements Serializable {
    private String iso2;
    private String name;

    public String getIso2() {
        return iso2;
    }

    public void setIso2(String iso2) {
        this.iso2 = iso2;
    }

    @Column(name = "countryName")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</pre></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2267"></a>2.4.3.2.&nbsp;公式</h4></div></div><div></div></div><p>有时候,你想让数据库,而非JVM,来替你完成一些计算,也可能想创建某种虚拟列.
		你可以使用SQL片段(亦称为公式),而不是将属性映射到(物理)列. 这种属性是只读的(属性值由公求得).</p><pre class="programlisting">@Formula("obj_length * obj_height * obj_width")
		public long getObjectVolume()</pre><p>SQL片段可以是任意复杂的,甚至可包含子查询.</p></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2276"></a>2.4.3.3.&nbsp;类型</h4></div></div><div></div></div><p><tt class="literal">@org.hibernate.annotations.Type</tt>
		覆盖了Hibernate所用的默认类型：这通常不是必须的,因为类型可以由Hibernate正确推得.
		关于Hibernate类型的详细信息,请参考Hibernate使用手册.</p><p><tt class="literal">@org.hibernate.annotations.TypeDef</tt> 和
		 <tt class="literal">@org.hibernate.annotations.TypeDefs</tt>允许你来声明类型定义.
		这些注解被置于类或包一级.注意,对session factory来说,
		这些定义将是全局的(即使定义于类一级),并且类型定义必须先于任何使用.</p><pre class="programlisting">@TypeDefs(
    {
    @TypeDef(
        name="caster",
        typeClass = CasterStringType.class,
        parameters = {
            @Parameter(name="cast", value="lower")
        }
    )
    }
)
package org.hibernate.test.annotations.entity;

...
public class Forest {
    @Type(type="caster")
    public String getSmallText() {
    ...
}
         </pre><p>当使用组合的用户自定义类型时,你必须自己表示列的定义.
<tt class="literal">@Columns</tt>就是为了此目的而引入的.</p><pre class="programlisting">@Type(type="org.hibernate.test.annotations.entity.MonetaryAmountUserType")
@Columns(columns = {
    @Column(name="r_amount"),
    @Column(name="r_currency")
})
public MonetaryAmount getAmount() {
    return amount;
}


public class MonetaryAmount implements Serializable {
    private BigDecimal amount;
    private Currency currency;
    ...
}</pre></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2299"></a>2.4.3.4.&nbsp;索引</h4></div></div><div></div></div><p>通过在列属性(property)上使用<tt class="literal">@Index</tt>注解,
		可以在特定列上定义索引,columnNames属性(attribute)将随之被忽略.</p><pre class="programlisting">@Column(secondaryTable="Cat1")
@Index(name="story1index")
public String getStoryPart1() {
    return storyPart1;
}</pre></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2309"></a>2.4.3.5.&nbsp;@Parent</h4></div></div><div></div></div><p>在嵌入式对象内部,你可以在那些指向该嵌入式对象所属元素的属性上定义该注解.</p><pre class="programlisting">@Entity
public class Person {
    @Embeddable public Address address;
    ...
}

@Embeddable
public class Address {
    @Parent public Person owner;
    ...
}


person == person.address.owner</pre></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2316"></a>2.4.3.6.&nbsp;生成的属性</h4></div></div><div></div></div><p>
		某些属性可以在对数据库做插入或更新操作的时候生成.
		Hibernate能够处理这样的属性,并触发一个后续的查询来读取这些属性.
		</p><pre class="programlisting">@Entity
public class Antenna {
    @Id public Integer id;
    @Generated(GenerationTime.ALWAYS) @Column(insertable = false, updatable = false)
    public String longitude;

    @Generated(GenerationTime.INSERT) @Column(insertable = false)
    public String latitude;
}</pre><p>
		你可以将属性注解为<tt class="literal">@Generated</tt>.
		但是你要注意insertability和updatability不要和你选择的生成策略冲突.
		如果选择了GenerationTime.INSERT,该属性不能包含insertable列,
		如果选择了GenerationTime.ALWAYS,该属性不能包含insertable和updatable列.</p><p><tt class="literal">@Version</tt>属性不可以为
        <tt class="literal">@Generated(INSERT)</tt>(设计时), 只能是
        <tt class="literal">NEVER</tt>或<tt class="literal">ALWAYS</tt>.</p></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2341"></a>2.4.4.&nbsp;继承</h3></div></div><div></div></div><p>SINGLE_TABLE 是个功能强大的策略,但有时,特别对遗留系统而言,
		是无法加入一个额外的辨别符列.
		由此,Hibernate引入了辨别符公式(discriminator formula)的概念：
		<tt class="literal">@DiscriminatorFormula</tt>是<tt class="literal">@DiscriminatorColumn</tt>的替代品,
		它使用SQL片段作为辨别符解决方案的公式( 不需要有一个专门的字段).</p><pre class="programlisting">@Entity
@DiscriminatorForumla("case when forest_type is null then 0 else forest_type end")
public class Forest { ... }</pre></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2354"></a>2.4.5.&nbsp;关于单个关联关系的注解</h3></div></div><div></div></div><p>默认情况下,当预期的被关联元素不在数据库中(关乎关联列的错误id),致使Hiberante无法解决关联性问题时,Hibernate就会抛出异常.
      这对遗留schema和历经拙劣维护的schema而言,这或有许多不便.
      此时,你可用 <tt class="literal">@NotFound </tt>注解让Hibernate略过这样的元素而不是抛出异常.
      该注解可用于 <tt class="literal">@OneToOne </tt> (有外键)、 <tt class="literal">@ManyToOne </tt>、  
      <tt class="literal">@OneToMany </tt> 或 <tt class="literal">@ManyToMany </tt>关联.</p><pre class="programlisting">@Entity
public class Child {
    ...
    @ManyToOne
    @NotFound(action=NotFoundAction.IGNORE)
    public Parent getParent() { ... }
    ...
}</pre><p>
	  有时候删除某实体的时候需要触发数据库的级联删除.</p><pre class="programlisting">@Entity
public class Child {
    ...
    @ManyToOne
    @OnDelete(action=OnDeleteAction.CASCADE)
    public Parent getParent() { ... }
    ...
}</pre><p>上面这个例子中,Hibernate将生成一个数据库级的级联删除约束.</p><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2382"></a>2.4.5.1.&nbsp;延迟选项和获取模式</h4></div></div><div></div></div><p>
		EJB3为延迟加载和获取模式提供了<tt class="literal">fetch</tt>选项,而Hibernate
		这方面提供了更丰富的选项集.为了更好的调整延迟加载和获取策略,Hibernate引入了
		一些附加的注解:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">@LazyToOne</tt>: 定义了
             <tt class="literal">@ManyToOne</tt> 和 <tt class="literal">@OneToOne</tt>
            关联的延迟选项. <tt class="literal">LazyToOneOption</tt> 可以是
            <tt class="literal">PROXY</tt> (例如:基于代理的延迟加载),
            <tt class="literal">NO_PROXY</tt> (例如:基于字节码增强的延迟加载 - 注意需要在构建期处理字节码)
            和 <tt class="literal">FALSE</tt> (非延迟加载的关联)</p></li><li><p><tt class="literal">@LazyCollection</tt>: 定义了
            <tt class="literal">@ManyToMany</tt>和
            <tt class="literal">@OneToMany</tt>  关联的延迟选项. LazyCollectionOption
            可以是<tt class="literal">TRUE</tt> (集合具有延迟性,只有在访问的时候才加载), 
			<tt class="literal">EXTRA</tt> (集合具有延迟性,并且所有的操作都会尽量避免加载集合,
			对于一个巨大的集合特别有用,因为这样的集合中的元素没有必要全部加载)和 FALSE
            (非延迟加载的关联)</p></li><li><p><tt class="literal">@Fetch</tt>: 
			定义了加载关联关系的获取策略. <tt class="literal">FetchMode</tt> 可以是
            <tt class="literal">SELECT</tt> (在需要加载关联的时候触发select操作), 
			<tt class="literal">SUBSELECT</tt>
            (只对集合有效,使用了子查询策略,详情参考Hibernate参考文档) or 
			<tt class="literal">JOIN</tt> (在加载主实体(owner entity)的时候使用SQL JOIN来加载关联关系).
            <tt class="literal">JOIN</tt> 将覆写任何延迟属性 
			(通过<tt class="literal">JOIN</tt>策略加载的关联将不再具有延迟性).</p></li></ul></div><p>The Hibernate annotations overrides the EJB3 fetching
        options.</p><p>Hibernate注解覆写了EJB3提供的获取(fetch)选项.</p><div class="table"><a name="d0e2458"></a><p class="title"><b>表&nbsp;2.3.&nbsp;延迟和获取选项的等效注解</b></p><table summary="延迟和获取选项的等效注解" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Annotations</th><th>Lazy</th><th>Fetch</th></tr></thead><tbody><tr><td>@[One|Many]ToOne](fetch=FetchType.LAZY)</td><td>@LazyToOne(PROXY)</td><td>@Fetch(SELECT)</td></tr><tr><td>@[One|Many]ToOne](fetch=FetchType.EAGER)</td><td>@LazyToOne(FALSE)</td><td>@Fetch(JOIN)</td></tr><tr><td>@ManyTo[One|Many](fetch=FetchType.LAZY)</td><td>@LazyCollection(TRUE)</td><td>@Fetch(SELECT)</td></tr><tr><td>@ManyTo[One|Many](fetch=FetchType.EAGER)</td><td>@LazyCollection(FALSE)</td><td>@Fetch(JOIN)</td></tr></tbody></table></div></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="entity-hibspec-collection"></a>2.4.6.&nbsp;关于集合类型的注解</h3></div></div><div></div></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2502"></a>2.4.6.1.&nbsp;参数注解</h4></div></div><div></div></div><p>以下是可能的设置方式</p><div class="itemizedlist"><ul type="disc"><li>
               用@BatchSizebatch设置集合的batch大小 
            </li><li>
               用@Where注解设置Where子句
            </li><li>
               用注解@Check来设置check子句
            </li><li>
               用注解@OrderBy来设置SQL的order by子句
            </li><li>
               利用@OnDelete(action=OnDeleteAction.CASCADE) 注解设置级连删除策略
            </li></ul></div><p>你也可以利用<tt class="literal">@Sort</tt>注解定义一个排序比较器(sort comparator),
		表明希望的比较器类型,无序、自然顺序或自定义排序,三者择一.若你想用你自己实现的comparator,
		你还需要利用<tt class="literal">comparator</tt>属性(attribute)指明实现类.</p><pre class="programlisting">    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @JoinColumn(name="CUST_ID")
    @Sort(type = SortType.COMPARATOR, comparator = TicketComparator.class)
    @Where(clause="1=1")
    @OnDelete(action=OnDeleteAction.CASCADE)
    public SortedSet&lt;Ticket&gt; getTickets() {
        return tickets;
    }</pre><p>关于这些注解更详细的信息,请参阅此前的描述.</p></div><div class="sect3" lang="zh_cn"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2530"></a>2.4.6.2.&nbsp;更多的集合类型</h4></div></div><div></div></div><p>比EJB3更胜一筹的是,Hibernate Annotations支持真正的
			<tt class="classname">List</tt>和<tt class="classname">Array</tt>.
			映射集合的方式和以前完全一样,只不过要新增<tt class="literal">@IndexColumn</tt>注解.
			该注解允许你指明存放索引值的字段.你还可以定义代表数据库中首个元素的索引值(亦称为索引基数).
			常见取值为<tt class="literal">0</tt>或<tt class="literal">1</tt>.</p><pre class="programlisting">@OneToMany(cascade = CascadeType.ALL)
@IndexColumn(name = "drawer_position", base=1)
public List&lt;Drawer&gt; getDrawers() {
    return drawers;
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>假如你忘了设置<tt class="literal">@IndexColumn</tt>,
			Hibernate会采用包(bag)语义(译注：即允许重复元素的无序集合).</p></div><p>Hibernate注解支持true Map映射,
		如果没有设置<tt class="literal">@javax.persistence.MapKey</tt>,
		hibernate将key元素或嵌入式对象直接映射到他们所属的列.
		要覆写默认的列,可以使用以下注解:
		<tt class="literal">@org.hibernate.annotations.MapKey</tt>适用的key为基本类型或者嵌入式对象,
		<tt class="literal">@org.hibernate.annotations.MapKey</tt>适用的key为实体.
        </p><p>Hibernate Annotations还支持核心类型集合(Integer, String, Enums, ......)、
		可内嵌对象的集合,甚至基本类型数组.这就是所谓的元素集合.</p><p>元素集合可用@CollectionOfElements来注解(作为@OneToMany的替代).
		为了定义集合表(译注：即存放集合元素的表,与下面提到的主表对应),要在关联属性上使用@JoinTable注解,
		joinColumns定义了介乎实体主表与集合表之间的连接字段(inverseJoincolumn是无效的且其值应为空).
		对于核心类型的集合或基本类型数组,你可以在关联属性上用<tt class="literal">@Column</tt>来覆盖存放元素值的字段的定义.
		你还可以用<tt class="literal">@AttributeOverride</tt>来覆盖存放可内嵌对象的字段的定义.
		要访问集合元素,需要将该注解的name属性值设置为"element"("element"用于核心类型,而"element.serial"
		用于嵌入式对象的serial属性).要访问集合的index/key,则将该注解的name属性值设置为"key".
		</p><pre class="programlisting">@Entity
public class Boy {
    private Integer id;
    private Set&lt;String&gt; nickNames = new HashSet&lt;String&gt;();
    private int[] favoriteNumbers;
    private Set&lt;Toy&gt; favoriteToys = new HashSet&lt;Toy&gt;();
    private Set&lt;Character&gt; characters = new HashSet&lt;Character&gt;();

    @Id @GeneratedValue
    public Integer getId() {
        return id;
    }

    <span class="bold"><b>@CollectionOfElements
    public Set&lt;String&gt;</b></span> getNickNames() {
        return nickNames;
    }

    <span class="bold"><b>@CollectionOfElements
    @JoinTable(
            table=@Table(name="BoyFavoriteNumbers"),
            joinColumns = @JoinColumn(name="BoyId")
    )
    @Column(name="favoriteNumber", nullable=false)</b></span>
    @IndexColumn(name="nbr_index")
    public int[] getFavoriteNumbers() {
        return favoriteNumbers;
    }

    <span class="bold"><b>@CollectionOfElements
    @AttributeOverride( name="element.serial", column=@Column(name="serial_nbr") )</b></span>
    public Set&lt;Toy&gt; getFavoriteToys() {
        return favoriteToys;
    }

    <span class="bold"><b>@CollectionOfElements
    public Set&lt;Character&gt;</b></span> getCharacters() {
        return characters;
    }
    ...
}

public enum Character {
    GENTLE,
    NORMAL,
    AGGRESSIVE,
    ATTENTIVE,
    VIOLENT,
    CRAFTY
}

@Embeddable
public class Toy {
    public String name;
    public String serial;
    public Boy owner;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSerial() {
        return serial;
    }

    public void setSerial(String serial) {
        this.serial = serial;
    }

    <span class="bold"><b>@Parent</b></span>
    public Boy getOwner() {
        return owner;
    }

    public void setOwner(Boy owner) {
        this.owner = owner;
    }


    public boolean equals(Object o) {
        if ( this == o ) return true;
        if ( o == null || getClass() != o.getClass() ) return false;

        final Toy toy = (Toy) o;

        if ( !name.equals( toy.name ) ) return false;
        if ( !serial.equals( toy.serial ) ) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = name.hashCode();
        result = 29 * result + serial.hashCode();
        return result;
    }
}</pre><p>
		在嵌入式对象的集合中,可以使用 <tt class="literal">@Parent</tt>注解嵌入式对象的某属性.
		该属性指向该嵌入式对象所属的集合实体.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>旧版的Hibernate Annotations用<tt class="literal">@OneToMany</tt>来标识集合元素.
			由于语义矛盾,我们引入了<tt class="literal">@CollectionOfElements</tt>注解.
			用<tt class="literal">@OneToMany</tt>来标识集合元素的这种旧有方式目前尚有效,
			但是不推荐使用,而且在以后的发布版本中不再支持这种方式.</p></div></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2613"></a>2.4.7.&nbsp;缓存</h3></div></div><div></div></div><p>为了优化数据库访问,你可以激活所谓的Hibernate二级缓存.该缓存是可以按每个实体和集合进行配置的.</p><p><tt class="literal">@org.hibernate.annotations.Cache</tt>定义了缓存策略及给定的二级缓存的范围.
		此注解适用于根实体(非子实体),还有集合.</p><pre class="programlisting">@Entity
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public class Forest { ... }</pre><pre class="programlisting">    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @JoinColumn(name="CUST_ID")
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    public SortedSet&lt;Ticket&gt; getTickets() {
        return tickets;
    }</pre><p></p><div class="programlistingco"><pre class="programlisting">@Cache(
    CacheConcurrencyStrategy usage();                 <span class="co">(1)</span>
    String region() default "";                       <span class="co">(2)</span>
    String include() default "all";                   <span class="co">(3)</span>
)</pre><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>usage: 给定缓存的并发策略(NONE,
            READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL)</p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>region (可选的)：缓存范围(默认为类的全限定类名或是集合的全限定角色名)</p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p><tt class="literal">include</tt> (可选的)：值为all时包括了所有的属性(proterty),
            为non-lazy时仅含非延迟属性(默认值为all)</p></td></tr></tbody></table></div></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2646"></a>2.4.8.&nbsp;过滤器</h3></div></div><div></div></div><p>Hibernate具有数据过滤器的概念,可在运行期应用于一个给定的session.过滤器需要事先定义好.</p><p><tt class="literal">@org.hibernate.annotations.FilterDef</tt> 或
      <tt class="literal">@FilterDefs</tt> 定义过滤器声明,为同名过滤器所用.
      过滤器声明带有一个name()和一个parameters()数组,<tt class="literal">@ParamDef</tt>包含name和type,
      你还可以为给定的<tt class="literal">@filterDef</tt>定义一个defaultCondition()参数,
      当<tt class="literal">@Filter</tt>中没有任何定义时,可使用该参数定义缺省条件.
     <tt class="literal">@FilterDef</tt> (s)可以在类或包一级进行定义.</p><p>现在我们来定义应用于实体或集合加载时的SQL过滤器子句.我们使用<tt class="literal">@Filter</tt>,并将其置于实体或集合元素上.</p><pre class="programlisting">@Entity
@FilterDef(name="minLength", parameters=@ParamDef( name="minLength", type="integer" ) )
@Filters( {
    @Filter(name="betweenLength", condition=":minLength &lt;= length and :maxLength &gt;= length"),
    @Filter(name="minLength", condition=":minLength &lt;= length")
} )
public class Forest { ... }</pre></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2678"></a>2.4.9.&nbsp;查询</h3></div></div><div></div></div><p>由于Hibernate引入了
      <tt class="literal">@org.hibernate.annotations.NamedQuery</tt>,
      <tt class="literal">@org.hibernate.annotations.NamedQueries</tt>,
      <tt class="literal">@org.hibernate.annotations.NamedNativeQuery</tt> 和
      <tt class="literal">@org.hibernate.annotations.NamedNativeQueries</tt> 命名式查询,
      因此Hibernate在命名式查询上比EBJ3规范中所定义的命名式查询提供了更多的特性.
      他们在标准版中添加了可作为替代品的一些属性(attributes):</p><div class="itemizedlist"><ul type="disc"><li><p>flushMode: 定义查询的刷新模式(Always, Auto, Commit或Manual)</p></li><li><p>cacheable: 查询该不该被缓存</p></li><li><p>cacheRegion: 若查询已被缓存时所用缓存的范围</p></li><li><p>fetchSize: 针对该查询的JDBC statement单次获取记录的数目</p></li><li><p>timeout: 查询超时</p></li><li><p>callable: 仅用于本地化查询(native query),对于存储过程设为true</p></li><li><p>comment: 一旦激活注释功能,我们会在向数据库交送查询请求时看到注释</p></li><li><p>cacheMode: 缓存交护模式(get, ignore,normal,或refresh)</p></li><li><p>readOnly: 不管是否从查询获取元素都是在只读模式下</p></li></ul></div><p>注意,EJB3已公开的最终草案中引入了<tt class="literal">@QueryHint</tt>的概念,
      这可能是定义hints更好的方法.</p></div></div></div><div class="chapter" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title"><a name="xml-overriding"></a>第&nbsp;3&nbsp;章&nbsp;通过XML覆写元数据</h2></div></div><div></div></div><p>在EJB3中元数据的主要目标是使用注释,但是EJB3规范也提供通过XML部署文件来覆写或者替换元数据注释.
  在当前的发布版本仅仅支持EJB3注释的覆写,如果你想使用Hibernate特有的一些实体注释,
  你有两种选择:一,只使用注释;二,使用原来的hbm 映射文件.你当然还是可以同时使用注释实体和hbm XML映射文件的实体.</p><p>在测试套件中有一些附加的XML文件的样例.</p><div class="section" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2735"></a>3.1.&nbsp;原则</h2></div></div><div></div></div><p>XML部署文件结构被设计为直接映射注释结构,所以如果你知道注释的结构,那么使用XML语法是很简单的.</p><p>你可以定义一个或者多个XML文件来描述你的元数据,这些文件会被覆写引擎合并(merged).</p><div class="section" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2742"></a>3.1.1.&nbsp;全局级别的元数据</h3></div></div><div></div></div><p>你可以使用XML文件来定义全局元数据,对每一个部署文件你不能定义多于一个的元数据.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;entity-mappings 
  xmlns="http://java.sun.com/xml/ns/persistence/orm"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/orm orm_1_0.xsd"
  version="1.0"&gt;

    &lt;persistence-unit-metadata&gt;
        &lt;xml-mapping-metadata-complete/&gt;
        &lt;persistence-unit-defaults&gt;
            &lt;schema&gt;myschema&lt;/schema&gt;
            &lt;catalog&gt;mycatalog&lt;/catalog&gt;
            &lt;cascade-persist/&gt;
        &lt;/persistence-unit-defaults&gt;
    &lt;/persistence-unit-metadata&gt;</pre><p><tt class="literal">xml-mapping-metadata-complete</tt> 意味着所有的实体,mapped-superclasses和嵌套的元数据应该从XML文件中启用(忽略注释).</p><p><tt class="literal">schema / catalog</tt> 将覆写所有在元数据中默认定义的schema 和 catalog(包括XML和注释).</p><p><tt class="literal">cascade-persist</tt> 意味着所有注释作为一个 cascade type 都是PERSIST的. 我们推荐你不要使用该特性.</p></div><div class="section" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2761"></a>3.1.2.&nbsp;实体级别的元数据</h3></div></div><div></div></div><p>你也可以在一个给定的实体上定义或者覆写元数据</p><div class="programlistingco"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;entity-mappings                                                                    <span class="co">(1)</span>
  xmlns="http://java.sun.com/xml/ns/persistence/orm"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/orm orm_1_0.xsd"
  version="1.0"&gt;

    &lt;package&gt;org.hibernate.test.annotations.reflection&lt;/package&gt;                    <span class="co">(2)</span>
    &lt;entity class="Administration" access="PROPERTY" metadata-complete="true"&gt;      <span class="co">(3)</span>
        &lt;table name="tbl_admin"&gt;                                                    <span class="co">(4)</span>
            &lt;unique-constraint&gt;
                &lt;column-name&gt;firstname&lt;/column-name&gt;
                &lt;column-name&gt;lastname&lt;/column-name&gt;
            &lt;/unique-constraint&gt;
        &lt;/table&gt;
        &lt;secondary-table name="admin2"&gt;                                             <span class="co">(5)</span>
            &lt;primary-key-join-column name="admin_id" referenced-column-name="id"/&gt;
            &lt;unique-constraint&gt;
                &lt;column-name&gt;address&lt;/column-name&gt;
            &lt;/unique-constraint&gt;
        &lt;/secondary-table&gt;
        &lt;id-class class="SocialSecurityNumber"/&gt;                                    <span class="co">(6)</span>
        &lt;inheritance strategy="JOINED"/&gt;                                            <span class="co">(7)</span>
        &lt;sequence-generator name="seqhilo" sequence-name="seqhilo"/&gt;                <span class="co">(8)</span>
        &lt;table-generator name="table" table="tablehilo"/&gt;                           <span class="co">(9)</span>
        ...
    &lt;/entity&gt;

    &lt;entity class="PostalAdministration"&gt;
        &lt;primary-key-join-column name="id"/&gt;                                        <span class="co">(10)</span>
        ...
    &lt;/entity&gt;
&lt;/entity-mappings&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p><tt class="literal">entity-mappings</tt>:entity-mappings 是所有XML文件的根元素.你必须定义XML Schema, 该文件包含在hibernate-annotations.jar中,使用Hibernate Annotations 不需要访问网络.</p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p><tt class="literal">package</tt> (可选的): 作为默认的package用于在一个给定的部署描述文件中所有没有限定的类.</p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p><tt class="literal">entity</tt>: 描述一个实体. </p><p><tt class="literal">metadata-complete</tt> 定义对于该元素是否全部使用元数据(换句话来说就是,如果注释出现在类级别应该考虑或者忽略).</p><p>一个实体不得不有一个 class 属性来引用 元数据所应用的类. </p><p>通过<tt class="literal">name</tt>属性你可以覆写实体的名字,
			如果没有定义并且<tt class="literal">@Entity.name</tt>出现了的话,那么就使用该注释(假如metadata complete 没有被设置).</p><p>
			对于metadata complete (参考下面)元素, 你可以定义一个  <tt class="literal">access</tt>(<tt class="literal">FIELD</tt> 或者 <tt class="literal">PROPERTY</tt>(默认值)),
			对于非metadata complete 元素,使用注释的access type.</p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p><tt class="literal">table</tt>:  你可以声明table 属性(name, schema, catalog), 如果没有定义, 将使用Java注释.</p><p>就象例子中所示的那样你可以定义一个或者多个unique constraints</p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p><tt class="literal">secondary-table</tt>: 定义一个secondary-table,除了你可以通过<tt class="literal">primary-key-join-column </tt>元素定义 primary key / foreign key 列以外是和一般的table一样的. 在非metadata complete下, annotation secondary tables 仅仅在没有<tt class="literal">secondary-table </tt>定义的情况下使用, 否则 注释将被忽略.</p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p><tt class="literal">id-class</tt>: 和<tt class="literal">@IdClass</tt>一样定义一个id class.</p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p><tt class="literal">inheritance</tt>: 
			定义继承策略(<tt class="literal">JOINED</tt>,
            <tt class="literal">TABLE_PER_CLASS</tt>,
            <tt class="literal">SINGLE_TABLE</tt>), 仅仅在根实体级别可以使用.</p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p><tt class="literal">sequence-generator</tt>: 定义一个序列产生器.</p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p><tt class="literal">table-generator</tt>: 定义一个table generator</p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p><tt class="literal"><tt class="literal">primary-key-join-column</tt></tt>:
            当 JOINED 继承策略使用时,为sub entities定义一个 primary key join column.</p></td></tr></tbody></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;entity-mappings 
  xmlns="http://java.sun.com/xml/ns/persistence/orm"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/orm orm_1_0.xsd"
  version="1.0"&gt;

    &lt;package&gt;org.hibernate.test.annotations.reflection&lt;/package&gt;
    &lt;entity class="Music" access="PROPERTY" metadata-complete="true"&gt;
        &lt;discriminator-value&gt;Generic&lt;/discriminator-value&gt;                          <span class="co">(1)</span>
        &lt;discriminator-column length="34"/&gt;
        ...
    &lt;/entity&gt;

    &lt;entity class="PostalAdministration"&gt;
        &lt;primary-key-join-column name="id"/&gt;
        &lt;named-query name="adminById"&gt;                                              <span class="co">(2)</span>
            &lt;query&gt;select m from Administration m where m.id = :id&lt;/query&gt;
            &lt;hint name="org.hibernate.timeout" value="200"/&gt;
        &lt;/named-query&gt;
        &lt;named-native-query name="allAdmin" result-set-mapping="adminrs"&gt;           <span class="co">(3)</span>
            &lt;query&gt;select *, count(taxpayer_id) as taxPayerNumber 
            from Administration, TaxPayer
            where taxpayer_admin_id = admin_id group by ...&lt;/query&gt;
            &lt;hint name="org.hibernate.timeout" value="200"/&gt;
        &lt;/named-native-query&gt;
        &lt;sql-result-set-mapping name="adminrs"&gt;                                     <span class="co">(4)</span>
            &lt;entity-result entity-class="Administration"&gt;
                &lt;field-result name="name" column="fld_name"/&gt;
            &lt;/entity-result&gt;
            &lt;column-result name="taxPayerNumber"/&gt;
        &lt;/sql-result-set-mapping&gt;
        &lt;attribute-override name="ground"&gt;                                          <span class="co">(5)</span>
            &lt;column name="fld_ground" unique="true" scale="2"/&gt;
        &lt;/attribute-override&gt;
        &lt;association-override name="referer"&gt;
            &lt;join-column name="referer_id" referenced-column-name="id"/&gt;
        &lt;/association-override&gt;
        ...
    &lt;/entity&gt;
&lt;/entity-mappings&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p><tt class="literal">discriminator-value /
            discriminator-column</tt>: 当SINGLE_TABLE继承策略使用时,定义鉴别器值 和 保存该值的列.</p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p><tt class="literal">named-query</tt>: 定义命名查询和一些相关的可能的线索. 该定义附加在注释的定义中,如果两个都定义了相同的名字,那么XML将优先考虑.</p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p><tt class="literal">named-native-query</tt>: 定义一个命名本地查询 和他的 sql result set  映射. 作为另外一种选择,你可以定义<tt class="literal">result-class</tt>. 这些定义附加在注释的定义中.如果两个定义了同样的名字,XML文件优先考虑.</p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p><tt class="literal">sql-result-set-mapping</tt>: 描述了 result set mapping 的结构. 你可以定义 实体和列映射. 这些定义附加在注释的定义中,如果定义了同样的名字,XML文件优先考虑.</p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p><tt class="literal">attribute-override /
            association-override</tt>: 定义一列或者join column overriding. 该overriding 附加在注释的定义中.</p></td></tr></tbody></table></div></div><p>一些应用于 <tt class="literal">&lt;embeddable&gt;</tt> 和
      <tt class="literal">&lt;mapped-superclass&gt;</tt>.</p></div><div class="section" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2923"></a>3.1.3.&nbsp;属性级别的元数据</h3></div></div><div></div></div><p>
	  你当然可以定义XML来覆写属性. 如果metadata complete 给定义了,那么附加的属性(如: 在Java 级别的)将被忽略.
另外,一旦你开始覆写一个属性,在该属性上的所有注释都会被忽略.所有属性级别的元数据应用于<tt class="literal">entity/attributes</tt>,
      <tt class="literal">mapped-superclass/attributes</tt> 或
      <tt class="literal">embeddable/attributes</tt>.</p><pre class="programlisting">    &lt;attributes&gt;
        &lt;id name="id"&gt;
            &lt;column name="fld_id"/&gt;
            &lt;generated-value generator="generator" strategy="SEQUENCE"/&gt;
            &lt;temporal&gt;DATE&lt;/temporal&gt;
            &lt;sequence-generator name="generator" sequence-name="seq"/&gt;
        &lt;/id&gt;
        &lt;version name="version"/&gt;
        &lt;embedded name="embeddedObject"&gt;
            &lt;attribute-override name"subproperty"&gt;
                &lt;column name="my_column"/&gt;
            &lt;/attribute-override&gt;
        &lt;/embedded&gt;
        &lt;basic name="status" optional="false"&gt;
            &lt;enumerated&gt;STRING&lt;/enumerated&gt;
        &lt;/basic&gt;
        &lt;basic name="serial" optional="true"&gt;
            &lt;column name="serialbytes"/&gt;
            &lt;lob/&gt;
        &lt;/basic&gt;
        &lt;basic name="terminusTime" fetch="LAZY"&gt;
            &lt;temporal&gt;TIMESTAMP&lt;/temporal&gt;
        &lt;/basic&gt;
    &lt;/attributes&gt;</pre><p>
	  通过 <tt class="literal">id</tt>,
      <tt class="literal">embedded-id</tt>, <tt class="literal">version</tt>,
      <tt class="literal">embedded</tt> 和 <tt class="literal">basic</tt>你可以覆写一个属性,
	  这些元素中的每一个元素都有相应的subelements：<tt class="literal">lob</tt>,
      <tt class="literal">temporal</tt>, <tt class="literal">enumerated</tt>,
      <tt class="literal">column</tt>.</p></div><div class="section" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2968"></a>3.1.4.&nbsp;关联级别的元数据</h3></div></div><div></div></div><p>你可以定义XML覆写关联注释. 所有的关联级别的元数据作用于
	   <tt class="literal">entity/attributes</tt>,
      <tt class="literal">mapped-superclass/attributes</tt> 或
      <tt class="literal">embeddable/attributes</tt>.</p><pre class="programlisting">    &lt;attributes&gt;
        &lt;one-to-many name="players" fetch="EAGER"&gt;
            &lt;map-key name="name"/&gt;
            &lt;join-column name="driver"/&gt;
            &lt;join-column name="number"/&gt;
        &lt;/one-to-many&gt;
        &lt;many-to-many name="roads" target-entity="Administration"&gt;
            &lt;order-by&gt;maxSpeed&lt;/order-by&gt;
            &lt;join-table name="bus_road"&gt;
                &lt;join-column name="driver"/&gt;
                &lt;join-column name="number"/&gt;
                &lt;inverse-join-column name="road_id"/&gt;
                &lt;unique-constraint&gt;
                    &lt;column-name&gt;driver&lt;/column-name&gt;
                    &lt;column-name&gt;number&lt;/column-name&gt;
                &lt;/unique-constraint&gt;
            &lt;/join-table&gt;
        &lt;/many-to-many&gt;
        &lt;many-to-many name="allTimeDrivers" mapped-by="drivenBuses"&gt;
    &lt;/attributes&gt;</pre><p>通过<tt class="literal">one-to-many</tt>, <tt class="literal">one-to-one</tt>,
      <tt class="literal">many-to-one</tt>, 和 <tt class="literal">many-to-many</tt>.
	  你可以重写一个关联关系.这些元素中的每一个都有相应的subelements. <tt class="literal">join-table</tt>  (可以有
	  <tt class="literal">join-column</tt>和
      <tt class="literal">inverse-join-column</tt>),
      <tt class="literal"><tt class="literal">join-column</tt></tt>,
      <tt class="literal">map-key</tt>, 和 <tt class="literal">order-by</tt>.
      <tt class="literal">mapped-by</tt> 和 <tt class="literal">target-entity</tt>
	  当他们有意义的时候可以定义属性. 再一次强调 该结构映射于注释的结构.在描述注释的一章中 你可以找到所有的语义信息.</p></div></div></div><div class="chapter" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title"><a name="validator"></a>第&nbsp;4&nbsp;章&nbsp;Hibernate验证器</h2></div></div><div></div></div><p>注解是一种为领域模型(domain model)指定不变约束的简洁而幽雅的方法。例如，你能
  表示一个属性永远不为null，一个帐户余额一定是正值，等等。这些域模型约束通过为bean中的属性添加
  注解来加以声明。随后一个验证器(validator)会读取并检查这些约束。验证机制可以执行于应用程序中的
  不同层（表现层、数据访问层），而不必复述任何（前述）这些规则。Hibernate验证器正为这一目的而设计的。</p><p>Hibernate验证器工作在两个层次上。第一层，它能检查内存中一个类的实例是否违反约束。
  第二层，它能将约束应用于Hibernate元模型上，并将它们融入生成的数据库schema中。</p><p>每个约束注解（constraint annotation）和一个验证器实现关联，该验证器负责检查位于实体实例上的约束。
  一个验证器也能(可选地)将约束应用于Hibernate元模型上，让Hibernate生成表示这一约束的DDL。使用合适的事件监听器，你能
  让Hibernate在插入和更新时执行检查操作。Hibernate验证器并不局限于同Hibernate一起使用。
  你能在你应用程序的任何地方方便地使用它。</p><p>在运行时检查实例时，Hibernate验证器返回违反约束的信息，
  这些信息以一个<tt class="classname">InvalidValue</tt>数组的形式返回。
  除了众多其他信息外，<tt class="classname">InvalidValue</tt>包含了一个错误描述消
  息，该信息可以内嵌与注解相捆绑的参数值（例如长度限制），以及能被提取至ResourceBundle的消息字串。</p><div class="sect1" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validator-constraints"></a>4.1.&nbsp;约束</h2></div></div><div></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3043"></a>4.1.1.&nbsp;什么是约束？</h3></div></div><div></div></div><p>约束通过注解表示。一个约束通常有一些用来参数化约束限制的属性。约束应用于带注解的元素。</p></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3048"></a>4.1.2.&nbsp;内建约束</h3></div></div><div></div></div><p>Hibernate验证器有些内建约束，这些约束覆盖了大多数的基本数据检查。随后我们会看到，
      你不必受制于这些内置约束，因为一分钟内就可以写出你自己的约束。</p><div class="table"><a name="d0e3053"></a><p class="title"><b>表&nbsp;4.1.&nbsp;内建约束</b></p><table summary="内建约束" border="1"><colgroup><col align="center"><col><col><col></colgroup><thead><tr><th align="center">注解</th><th>应用目标</th><th>运行时检查</th><th>Hibernate元数据影响</th></tr></thead><tbody><tr><td align="center">@Length(min=, max=)</td><td>属性(String)</td><td>检查字符串长度是否符合范围</td><td>列长度会被设到最大值</td></tr><tr><td align="center">@Max(value=)</td><td>属性 (以numeric或者string类型来表示一个数字)</td><td>检查值是否小于或等于最大值</td><td>对列增加一个检查约束</td></tr><tr><td align="center">@Min(value=)</td><td>属性(以numeric或者string类型来表示一个数字)</td><td>检查值是否大于或等于最小值</td><td>对列增加一个检查约束</td></tr><tr><td align="center">@NotNull</td><td>属性</td><td>检查值是否非空(not null)</td><td>列不为空</td></tr><tr><td align="center">@Past</td><td>属性(date或calendar)</td><td>检查日期是否是过去时</td><td>对列增加一个检查约束</td></tr><tr><td align="center">@Future</td><td>属性 (date 或 calendar)</td><td>检查日期是否是将来时</td><td>无</td></tr><tr><td align="center">@Pattern(regex="regexp", flag=)</td><td>属性 (string)</td><td>检查属性是否与给定匹配标志的正则表达式相匹配(见<tt class="classname"> 
              java.util.regex.Pattern </tt>)</td><td>无</td></tr><tr><td align="center">@Range(min=, max=)</td><td>属性(以numeric或者string类型来表示一个数字)</td><td>检查值是否在最小和最大值之间(包括临界值)</td><td>对列增加一个检查约束</td></tr><tr><td align="center">@Size(min=, max=)</td><td>属性 (array, collection, map)</td><td>检查元素大小是否在最小和最大值之间(包括临界值)</td><td>无</td></tr><tr><td align="center">@AssertFalse</td><td>属性</td><td>检查方法的演算结果是否为false(对以代码方式而不是注解表示的约束很有用)</td><td>无</td></tr><tr><td align="center">@AssertTrue</td><td>属性</td><td>检查方法的演算结果是否为true(对以代码方式而不是注解表示的约束很有用)</td><td>无</td></tr><tr><td align="center">@Valid</td><td>属性 (object)</td><td>对关联对象递归的进行验证。如果对象是集合或数组，就递归地验证其元素。如果对象是Map，则递归验证其值元素。</td><td>无</td></tr><tr><td align="center">@Email</td><td>属性（String）</td><td>检查字符串是否符合有效的email地址规范。</td><td>无</td></tr></tbody></table></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="validator-constraints-error"></a>4.1.3.&nbsp;错误信息</h3></div></div><div></div></div><p>Hibernate验证器提供了一组默认的错误提示信息，它们被翻译成多种语言(如果你的语言不在其中，请给
      我们寄一个补丁)。你可以在<tt class="filename">org.hibernate.validator.resources.DefaultValidatorMessages.properties</tt>
      之外创建<tt class="filename">ValidatorMessages.properties</tt>或<tt class="filename">ValidatorMessages_loc.properties</tt>
      文件并改变相应的键值，籍此覆盖那些（默认）信息。你甚至可以在写自己的验证器
      注解时添加你自己的附加消息集。</p><p>或者你可以以编程方式检查bean的验证规则并提供相应的<tt class="classname">ResourceBundle</tt>。</p></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3208"></a>4.1.4.&nbsp;编写你自己的约束</h3></div></div><div></div></div><p>扩展内建约束集是极其方便的。任何约束都包括两部分：约束<span class="emphasis"><em>描述符</em></span>(注解)
      和约束<span class="emphasis"><em>验证器</em></span>(实现类)。下面是一个简单的用户定义描述符：</p><pre class="programlisting">@ValidatorClass(CapitalizedValidator.class)
@Target(METHOD) 
@Retention(RUNTIME)
@Documented
public @interface Capitalized {
    CapitalizeType type() default Capitalize.FIRST;
    String message() default "has incorrect capitalization";
}</pre><p><tt class="literal">type</tt>参数描述属性应该如何被大写。这是一个完全依赖于注解业务(逻辑)的用户
      参数。</p><p><tt class="literal">message</tt>是用于描述约束违规的默认字符串，它是强制要求的。你可以采取硬编码的方式，
      或者通过Java ResourceBundle机制将message的部分/全部内容提取至外部文件。一旦发现message中{parameter}字符串，
      就会在{parameter}这个位置注入相应的参数值(在我们的例子里Capitalization is not {type}会生成 Capitalization is not FIRST)，
      可以将message对应的整个字符串提取至外部文件ValidatorMessages.properties，这也是一种良好实践。
      见<a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#validator-constraints-error">Error messages</a>。</p><pre class="programlisting">@ValidatorClass(CapitalizedValidator.class)
@Target(METHOD) 
@Retention(RUNTIME)
@Documented
public @interface Capitalized {
    CapitalizeType type() default Capitalize.FIRST;
    String message() default "{validator.capitalized}";
}

...
#in ValidatorMessages.properties
validator.capitalized=<tt class="literal">Capitalization is not {type}</tt></pre><p>如你所见{}符号是递归的。</p><p>为了将一个描述符连接到它的验证器实现，我们使用<tt class="literal">@ValidatorClass</tt>
      元注解。验证器类参数必须指定一个实现了<tt class="literal">Validator&lt;ConstraintAnnotation&gt;</tt>
      的类。</p><p>我们现在要实现验证器(也就是实现规则检查)。一个验证器实现能检查一个属性的值
      (实现<tt class="literal">PropertyConstraint</tt>)，并且/或者可以修改hibernate映射元数据
      (实现<tt class="literal">PersistentClassConstraint</tt>)，籍此表示数据库级的约束。</p><pre class="programlisting">public class CapitalizedValidator 
        implements Validator&lt;Capitalized&gt;, PropertyConstraint {
    private CapitalizeType type;

    //part of the Validator&lt;Annotation&gt; contract, 
    //allows to get and use the annotation values
    public void initialize(Capitalized parameters) {
        type = parameters.type();
    }

    //part of the property constraint contract
    public boolean isValid(Object value) {
        if (value==null) return true;
        if ( !(value instanceof String) ) return false;
        String string = (String) value;
        if (type == CapitalizeType.ALL) {
            return string.equals( string.toUpperCase() );
        }
        else {
            String first = string.substring(0,1);
            return first.equals( first.toUpperCase();
        }
    }
}</pre><p>如果违反约束，<tt class="literal">isValid()</tt>方法将返回false。更多例子请参考内建验证器实现。</p><p>至此我们只看到属性级的验证，你还可以写一个Bean级别的验证注解。Bean自身会被传递给验证器，
      而不是bean的属性实例。只要对bean自身进行注解即可激活验证检查。在单元测试套件中还可以找到一个小例子。</p></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3262"></a>4.1.5.&nbsp;注解你的领域模型</h3></div></div><div></div></div><p>既然你现在已经熟悉注解了，那么对语法也应该很清楚了。</p><pre class="programlisting">public class Address {
    private String line1;
    private String line2;
    private String zip;
    private String state;
    private String country;
    private long id;
    
    // a not null string of 20 characters maximum
    @Length(max=20) 
    @NotNull
    public String getCountry() {
        return country;
    }
    
    // a non null string
    @NotNull
    public String getLine1() {
        return line1;
    }

    //no constraint    
    public String getLine2() {
        return line2;
    }
    
    // a not null string of 3 characters maximum
    @Length(max=3) @NotNull
    public String getState() {
        return state;
    }

    // a not null numeric string of 5 characters maximum
    // if the string is longer, the message will 
    //be searched in the resource bundle at key 'long'
    @Length(max=5, message="{long}")
    @Pattern(regex="[0-9]+")
    @NotNull
    public String getZip() {
        return zip;
    }
    
    // should always be true
    @AssertTrue
    public boolean isValid() {
        return true;
    }

    // a numeric between 1 and 2000
    @Id @Min(1)
    @Range(max=2000)
    public long getId() {
        return id;
    }
}</pre><p>上面的例子只展示了公共属性验证，你还可以对任何可见度的字段(field)进行注解。</p><pre class="programlisting">@MyBeanConstraint(max=45)
public class Dog {
    @AssertTrue private boolean isMale;
    @NotNull protected String getName() { ... };
    ...
}</pre><p>你可以对接口进行注解。Hibernate验证器会检查给定bean所扩展或实现的所有父类和接口，
      籍以读取相应的验证器注解(信息)。</p><pre class="programlisting">public interface Named {
    @NotNull String getName();
    ...
}

public class Dog implements Named {

    @AssertTrue private boolean isMale;

    public String getName() { ... };

}</pre><p>在验证Dog bean时会检查name属性的有效性(不为null)。</p></div></div><div class="sect1" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3279"></a>4.2.&nbsp;使用验证器框架</h2></div></div><div></div></div><p>Hibernate验证器旨在实现多层数据验证，我们在一处表示约束(带注解的域模型)，然后将其运用于
    应用程序的不同层。</p><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3284"></a>4.2.1.&nbsp;数据库schema层次验证</h3></div></div><div></div></div><p>无须额外手续，Hibernate Annotations会自动将你为实体定义的约束翻译为映射元数据。例如，如果你的实体
      的一个属性注解为<tt class="literal">@NotNull</tt>，在Hibernate生成的DDL schema中这列会被定义为
      <tt class="literal">not null</tt>。</p></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3295"></a>4.2.2.&nbsp;Hibernate基于事件的验证</h3></div></div><div></div></div><p>Hibernate验证器有两个内建Hibernate事件监听器。当一个<tt class="literal">PreInsertEvent</tt>
      或<tt class="literal">PreUpdateEvent</tt>发生时，监听器会验证该实体实例的所有约束，如有违反会抛出一个异常。
      基本上，在Hibernate执行任何插入和更新前对象会被检查。这是激活验证过程的最便捷最简单的方法。当遇到约束
      违规时，事件会引发一个运行时<tt class="classname">InvalidStateException</tt>，该异常包含一个描述每个错误的
      <tt class="literal">InvalidValue</tt>数组。</p><pre class="programlisting">&lt;hibernate-configuration&gt;
    ...
    &lt;event type="pre-update"&gt;
        &lt;listener 
          class="org.hibernate.validator.event.ValidatePreUpdateEventListener"/&gt;
    &lt;/event&gt;
    &lt;event type="pre-insert"&gt;
        &lt;listener 
          class="org.hibernate.validator.event.ValidatePreInsertEventListener"/&gt;
    &lt;/event&gt;
&lt;/hibernate-configuration&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>在使用Hibernate Entity Manager时，Validation框架会被自动激活。如果bean不带验证注解，
          就不会有性能损失。</p></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3318"></a>4.2.3.&nbsp;程序级验证</h3></div></div><div></div></div><p>Hibernate验证器能应用于你应用程序代码中的任何地方。</p><pre class="programlisting">ClassValidator personValidator = new ClassValidator( Person.class );
ClassValidator addressValidator = new ClassValidator( Address.class, ResourceBundle.getBundle("messages", Locale.ENGLISH) );

InvalidValue[] validationMessages = addressValidator.getInvalidValues(address);</pre><p>头两行为执行类检查而准备Hibernate验证器。第一行依赖于嵌入在Hibernate验证器内的错误
      消息(见<a href="http://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/#validator-constraints-error">Error messages</a>)，第二行为这些消息准备资源包。这些代码只执行一次，
      并将验证器进行缓存处理，这种方式是一种良好实践。</p><p>第三行真正验证了<tt class="literal">Address</tt>实例并返回一个<tt class="literal">InvalidValue</tt>数组。
      你的应用程序逻辑随后可以对错误做出响应。</p><p>除了针对整个bean你还可以对某个特定属性进行检查。这对于一个属性一个属性的用户交互情形或许是有用的。</p><pre class="programlisting">ClassValidator addressValidator = new ClassValidator( Address.class, ResourceBundle.getBundle("messages", Locale.ENGLISH) );

//only get city property invalid values
InvalidValue[] validationMessages = addressValidator.getInvalidValues(address, "city");

//only get potential city property invalid values
InvalidValue[] validationMessages = addressValidator.getPotentialInvalidValues("city", "Paris")</pre></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3341"></a>4.2.4.&nbsp;验证信息</h3></div></div><div></div></div><p>作为一个验证信息的载体，hibernate提供了一个<tt class="classname">InvalidValue</tt>数组。
      每个<tt class="literal">InvalidValue</tt>有一组，这些方法分别描述相应的个体问题。</p><p><tt class="methodname">getBeanClass()</tt>获取失败的bean类型。</p><p><tt class="methodname">getBean()</tt>获取验证失败的实例(如果有的话，当使用
      <tt class="methodname">getPotentianInvalidValues()</tt>时则不会取到) </p><p><tt class="methodname">getValue()</tt>获取验证失败的值</p><p><tt class="methodname">getMessage()</tt>获取合适的国际化错误消息</p><p><tt class="methodname">getRootBean()</tt>获取产生问题的根bean实例(在与<tt class="literal">@Valid</tt>连用
      时很有用)，如用getPotentianInvalidValues()则返回null。</p><p><tt class="literal">getPropertyPath()</tt>获取“问题”属性从根bean开始的带点的路径</p></div></div></div><div class="chapter" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title"><a name="lucene"></a>第&nbsp;5&nbsp;章&nbsp;Hibernate与Lucene集成</h2></div></div><div></div></div><p>Lucene是一个高性能的java搜索引擎库，可以从 Apache软件基金组织获取。
  Hibernate Annotations包括一个注解包，它允许把任何域模型对象标记为可索引的，
  并且对任何经由Hibernate进行持续化的实例，Hibernate 都会为之维护一个对应的Lucene索引。</p><div class="sect1" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lucene-intro"></a>5.1.&nbsp;使用Lucene为实体建立索引</h2></div></div><div></div></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3390"></a>5.1.1.&nbsp;注解领域模型</h3></div></div><div></div></div><p>首先，必须将一个持久类声明为
      <tt class="literal">@Indexed</tt>:</p><pre class="programlisting">@Entity
@Indexed(index="indexes/essays")
public class Essay {
    ...
}</pre><p>属性<tt class="literal">index</tt>是告诉Hibernate， Lucene索引信息所在的位置（你文件系统的某个目录）。
	  如果你想为所有的Lucene索引定义一个根目录，你可以在配置文件中用属性<tt class="literal">hibernate.lucene.index_dir</tt>进行配置。
	  </p><p>Lucene索引包括四种字段：<span class="emphasis"><em>keyword</em></span> 字段，<span class="emphasis"><em>text</em></span>
      字段，<span class="emphasis"><em>unstored</em></span>字段和<span class="emphasis"><em>unindexed</em></span>字段。
      Hibernate注解提供了将实体属性标记为前三种被索引字段的注解。</p><pre class="programlisting">@Entity
@Indexed(index="indexes/essays")
public class Essay {
    ...

    @Id
    @Keyword(id=true)
    public Long getId() { return id; }
    
    @Text(name="Abstract")
    public String getSummary() { return summary; }
    
    @Lob
    @Unstored
    public String getText() { return text; }
    
}</pre><p>这些注解定义了一个带有三个字段的索引:
      <tt class="literal">Id</tt>, <tt class="literal">Abstract</tt> 和
      <tt class="literal">Text</tt>.</p><p>注意:你必须在你的实体类的标志属性上指定
      <tt class="literal">@Keyword(id=true)</tt> .</p><p>用于对元素建立索引的分析器类是可以通过<tt class="literal">hibernate.lucene.analyzer</tt>属性进行配置的。
	  如果没有定义，则把 <tt class="classname">org.apache.lucene.analysis.standard.StandardAnalyzer</tt>作为缺省。</p></div><div class="sect2" lang="zh_cn"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3448"></a>5.1.2.&nbsp;启用自动索引</h3></div></div><div></div></div><p>我们激活用于帧听三类Hibernate事件的 <tt class="literal">LuceneEventListener</tt>，
	  这些事件会在变更被提交至数据库后产生。</p><pre class="programlisting">&lt;hibernate-configuration&gt;
    ...
    &lt;event type="post-commit-update" 
        &lt;listener  
            class="org.hibernate.lucene.event.LuceneEventListener"/&gt;
    &lt;/event&gt;
    &lt;event type="post-commit-insert" 
        &lt;listener 
            class="org.hibernate.lucene.event.LuceneEventListener"/&gt;
    &lt;/event&gt;
    &lt;event type="post-commit-delete" 
        &lt;listener 
            class="org.hibernate.lucene.event.LuceneEventListener"/&gt;
    &lt;/event&gt;
&lt;/hibernate-configuration&gt;</pre></div></div></div><div class="appendix" lang="zh_cn"><div class="titlepage"><div><div><h2 class="title"><a name="d0e3458"></a>附录&nbsp;A.&nbsp;术语表</h2></div></div><div></div></div><p>Redsaga的wiki上维护了本文翻译过程中所参照的中英文对照的术语表,地址:http://wiki.redsaga.com/confluence/display/HART/glossary.</p></div></div></body></html>